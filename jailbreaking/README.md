# Jailbreaking

- Jailbreaking arises from the sandboxing solution relevant now-a-days.

- **A small history**: Early computers ran everything on hardware, implying that all processes were root essentially. Then came the split: Operating system (not affected by user) and userspace. But still, processes could starve each other and could clash shared memory. Then came virtual memory, which is hardware based solution to have different views for different processes. Then came *in-process* separation, which is the separation of the interpreter and the interpreter code (in scripting languages). 

- The basic motivation for sandboxing is that if everything is kept together, vulnerability with one leads to vulnerability in other. Sandboxing: untrusted code/data should live in a process with almost zero privileges, and all privileged stuff is requested from the parent. Sandboxing is very effective.

## chroot

- changes the meaning of `/` for a process and its children. It basically disallows processes to exit out of a jail.

```s
sudo chroot /tmp/jail /bin/bash
```
This means `/tmp/jail/bin/bash` which doesn't exist. So chroot disallows stuff outside the jail. You could have `busybox` inside the jail; busybox being statically linked is not cumbersome to set up in a jail.

- What `chroot` doesn't:
	- close resources that reside outside the jail: can use a bunch of syscalls like `openat`, `linkat` to cling to file descriptors not closed before `chroot`
	- doesn't cd (chdir()) into the jail
	- do anything else

Unclosed resources problems: `execve` and `open` have variants `execveat()` and `openat()` that take in a resource (file descriptor of a directory) and everything shall be relative to that directory now. `fchdir()` can `chdir` to a certain file descriptor; and if you have open file descriptors before jailing, you can easily escape. However, in case you don't have open file descriptors, you can use a combination of another C binary and `dup2()` syscalls to force a process' file descriptors as
you want and then a `execv(...)` to do the thing you want.

- Kernel has no memory of previous chroots for a process. If you chroot again, that can help to escape. If the effective UID is 0, the user can always break out of the jail unless the chroot syscall itself is blocked. **How?** Suppose you are working in `./` and the process you are in has **CAP_SYS_CHROOT**, you can `mkdir` and `chroot` in. Now `chroot` changes the definition of `/` for the process. This second `chroot` technically places `/` in a **subdirectory** wherein you are in the parent directory. Do a bunch of `cd ..` and you can escape to the actual `/`

- chroot is missing isolation in terms of IPC, networks, and PID. This means processes in the jail can talk to other stuff outside the jail, can use resources, and other stuff.

- Replacements: cgroups, seccomp, namespaces.

## seccomp

- seccomp is a kernel-level sandboxing mechanism that allows devs to write complex rules to allow/disallow certain system calls and certain syscall call function signatures.

- seccomp rules are inherited by the children.

- uses the kernel functionality eBPF (extended Berkeley Packet Filters) that run in-kernel and safe virtual machine

## Escaping seccomp

- Although a lot of good software relies on seccomp, the underlying truth is that the processes have to "talk" to the outside world for something. This presents an attack surface for adversaries to exploit. Overly permissible seccomp configuration can allow jailbreaking

- **ptrace()**: allows a sandbox allows to *puppet* non-sandboxed process

- **sendmsg()**: can transfer file decriptors between processors

- **prctl()**: bizzare effects

- **process_vm_writev()**: allows direct access to other process' memory

**Syscall confusion**: Most architectures are backware compatible with older architectures, and syscall numbers are different for all. For instance, let's say there is a seccomp rule that disallows 64-bit syscalls that read and forgot to disallow 32-bit read, I can still read.

**Kernel vulnerabilities**: If the seccomp is correctly configured, you can still use the allowed syscalls to trigger kernel vulnerabilities.

**Is your goal is always code execution?**

	- Data exfiltration (read a file etc)

	- Other signals

		- Runtime of a process: sleep(x) syscall

		- Clean termination or crash

		- Return value from exit(x)

	- Attackers can use DNS queries to bypass network filters

	- As long as you can communicate 1 bit, you can repeat the attack

# pwn.college level specific ideas

## Level 1

`chroot` does guard against path traversals, but only iff it is inside the jail. Forgetting a `chdir()` is dangerous.

## Level 2

A refresher of the idea that when `chroot` is called, it doesn't close already existing file descriptors. If you have a certain directory already open, you can use `openat` to get at it

## Level 3

Although there is a `chdir` after the `chroot`, however the file descriptor is still open. So if you open a file descriptor to the root directory before the`chdir`, nothing really changes. You can still do a `openat` and it will work.

## Level 4

A very basic introduction to `seccomp` rules. A bunch of syscalls were allowed (`openat` and `sendfile` being in them). So simply run the shellcode crafted in level 2 and it works.

## Level 5

Beware of **Invalid cross-device link**, implying trying to create a hard link between two filesystems (consider the jail to be a separate filesystem altogether). However, the same syscall `linkat(3, "flag", AT_FDCWD, "flag", 0)` produces a cross-device link on my local system but works on the remote system.

Anyway, use linkat to create a local hardlink. Then open it and read.

## Level 6

`fchdir(int fd)` changes directory with respect to some file descriptor. And if you have some unclosed descriptor before `chroot`, you are bound to have problems

## Level 7

From the linux manual, **In particular, the superuser can escape from a "chroot jail" by doing: mkdir foo; chroot foo; cd ..; cd ..; cd ..; sendfile(...)**

## Level 8

The level 3 shellcode works as it is. The only difference is that the level does not open a file descriptor. So we need to force such a file descriptor. Thereby, do a separate C program with `fork()`, `dup2()` to replace file descriptors, and `execv()` to run the challenge binary. You can also do a `dup(/*something*/, 0)` to do a input redirection as well.
