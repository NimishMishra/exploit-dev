#ifndef __CLASSDEF_H_
#define __CLASSDEF_H_


#include <vector>
#include <string>
#include <iostream>
using namespace std;

        // Root of the tree
        class Node{
                public:
                        virtual ~Node(){}
        }; // root class ends

        // sub-base class for expression values
        class Expression : public Node{
                public:
                        string operation = "";
                        virtual void debug(){}
        };

        // sub-base class for statements. When an expression node will be typecasted into Statement, the operation instance variable will automatically be binded at run time
        class Statement : public Node{
                public:
                        string operation;
        };

        ////////////// subclasses of Expression : store various kinds of evaluated expressions

        class Integer : public Expression{
                public:
                        int value;
                        Integer(int value) : value(value){}
                        void debug(){printf("[DEBUG] Value: %d\n", value);}
        };

	class Real : public Expression{
		public:
			double value;
			Real(double value) : value(value){}
			void debug(){printf("[DEBUG] Value: %f\n", value);}
	};

typedef std::vector<Statement*> StatementList;
typedef std::vector<Expression*> ExpressionList;

    class Block : public Expression {
    	public:
    		StatementList block_statements;
    		string operation;
    		Block(){}
    		void debug(){
    		        for(Statement* element : block_statements){
    		            cout << element << " (" << element->operation << " node) ";
    		    
    		    }
    		}
    };

    class Identifier : public Expression{
        public:
            string identifier;
            Identifier(string identifier) : identifier (identifier){}
            void debug(){
                cout << "[DEBUG] Identifier: " << identifier << endl;
            }
    };
    
    class Add : public Expression {
        public:
              char _operator;
              Expression* lhs;
              Expression* rhs;
              Add (Expression* lhs, char _operator, Expression* rhs) : _operator(_operator), lhs(move(lhs)), rhs(move(rhs)){}
              void debug(){
                cout << "[DEBUG] ADD " << endl;
              }
    };
    
    class Sub : public Expression {
        public:
              char _operator;
              Expression* lhs;
              Expression* rhs;
              Sub (Expression* lhs, char _operator, Expression* rhs) : _operator(_operator), lhs(move(lhs)), rhs(move(rhs)){}
              void debug(){
                cout << "[DEBUG] SUB " << endl;
              }
    };

    class Multiply : public Expression {
        public:
              char _operator;
              Expression* lhs;
              Expression* rhs;
              Multiply (Expression* lhs, char _operator, Expression* rhs) : _operator(_operator), lhs(move(lhs)), rhs(move(rhs)) {}
              void debug(){
                cout << "[DEBUG] MUL " << endl;
              }
    };
    
    class Divide : public Expression {
        public:
              char _operator;
              Expression* lhs;
              Expression* rhs;
              Divide (Expression* lhs, char _operator, Expression* rhs) : _operator(_operator), lhs(move(lhs)), rhs(move(rhs)) {}
              void debug(){
                cout << "[DEBUG] DIVIDE " << endl;
              }
    };
    
    class Assignment : public Expression{
        public:
            Expression* lvalue;
            Expression* rvalue;
            Assignment (Expression* lvalue, Expression* rvalue) : lvalue(move(lvalue)), rvalue(move(rvalue)){
                operation = "assignment";
            }
            void debug(){
                cout << "[DEBUG] Assignment\n";
            }
    };
    
    class Negate : public Expression {
        public:
            Expression* rvalue;
            Negate (Expression* rvalue) : rvalue(move(rvalue)){
                operation = "negation";
            }
            void debug(){
                cout << "[DEBUG] Negation\n";
            }
    };
    
    class OR : public Expression {
        public:
            Expression* lhs;
            Expression* rhs;
            OR (Expression* lhs, Expression* rhs) : lhs(move(lhs)), rhs(move(rhs)){
                operation = "or";
            }
            void debug(){
                cout << "[DEBUG] OR\n";
            }
    };
    
    class AND : public Expression {
        public:
            Expression* lhs;
            Expression* rhs;
            AND (Expression* lhs, Expression* rhs) : lhs(move(lhs)), rhs(move(rhs)){
                operation = "and";
            }
            void debug(){
                cout << "[DEBUG] AND\n";
            }
    };
    
    class Symbol {
        public:
                Symbol(string identifier, Expression* identifier_node):identifier(identifier), identifier_node(move(identifier_node)){}
                string identifier;
                Expression* identifier_node;
    };
    
    class NOT : public Expression{
        public:
            Expression* rhs;
            NOT(Expression* rhs) : rhs(move(rhs)) {
                operation = "not";
            }
            void debug(){
                cout << "[DEBUG] NOT\n";
            }
    };
    
    class EQUALITY : public Expression {
        public:
            Expression* lhs;
            Expression* rhs;
            EQUALITY(Expression* lhs, Expression* rhs) : lhs(move(lhs)), rhs(move(rhs)){
                operation = "equality";
            }
            void debug(){
                cout << "[DEBUG] EQUALITY\n";
            }
    };
    
    class LESS_THAN : public Expression {
        public:
            Expression* lhs;
            Expression* rhs;
            LESS_THAN(Expression* lhs, Expression* rhs) : lhs(move(lhs)), rhs (move(rhs)) {
                operation = "less than";
            }
            void debug(){
                cout << "[DEBUG] LESS THAN\n";
            }
    };
    
    class IF_BLOCK : public Block {
        public:
            Statement* condition;
            Block*  if_statements;
            Block*  else_statements;

            
            IF_BLOCK(Statement* condition, Block* if_statements, Block* else_statements) : condition(move(condition)), if_statements(move(if_statements)), else_statements(move(else_statements)){
                operation = "IF block";
                
                block_statements.push_back(condition);
                if(if_statements != NULL)
                    {
                         for(Statement* statement : if_statements->block_statements)
                                block_statements.push_back(statement);  
                    }    
                if(else_statements != NULL){
                         for(Statement* statement : else_statements->block_statements)
                                block_statements.push_back(statement);  
                }            
                
            }
            
            
    };
    
    class WHILE_BLOCK : public Block {
        
        public:
        Statement* condition;
        Block* while_statements;
        
        WHILE_BLOCK(Statement* condition, Block* while_statements) : condition(move(condition)), while_statements(move(while_statements)) {
        
            block_statements.push_back(condition);
            for (Statement* statement : while_statements->block_statements){
                block_statements.push_back(statement);
            }
        
        }
    };
    
    class FOR_BLOCK : public Block{
    
        public:
            Statement* condition;
            Block* assign;
            Block* update;
            Block* for_statements;
            
            FOR_BLOCK(Statement* condition, Block* assign, Block* update, Block* for_statements) : condition(move(condition)), assign(move(assign)), update(move(update)), for_statements(move(for_statements)) {
                block_statements.push_back(condition);
                for (Statement* statement : assign->block_statements)
                    block_statements.push_back(statement);
                for (Statement* statement : update->block_statements)
                    block_statements.push_back(statement);
                for (Statement* statement : for_statements->block_statements)
                    block_statements.push_back(statement);
            }
    };
    

#endif


