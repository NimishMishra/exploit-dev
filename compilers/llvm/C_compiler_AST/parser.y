%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <memory.h>
	#include <utility>
	#include "classdef.h"
	#include <string>
	using namespace std;

	extern int yylineno;
	extern FILE* yyin;
	extern int yylex();	
	int yyerror(char* s){
	        printf("Error: %s at line number %d\n", s, yylineno);

	}

	std::vector<Symbol*> symbol_table;
	
	Block* master_block;	

	// Functions aiding building syntax tree nodes
	
	static Expression* parseIntegers(int readValue){
		auto object = new Integer(readValue);
		cout << "[NODE] INTEGER node created at " << object << " with value " << readValue << endl;
		return move(object);
	}

	static Expression* parseReals(double value){
		auto object = new Real(value);
		cout << "[NODE] REAL node created at " << object << " with value " << value << endl;
		return move(object);
	}
	
	static Expression* parseIdentifier(string identifier){
	 
	    for(Symbol* symbol : symbol_table){
	        if(symbol->identifier == identifier)
	            return symbol-> identifier_node;
	    }
	 
	    auto object = new Identifier(identifier);
	    cout << "[NODE] Identifier node created at " << object << " with value " << identifier << endl; 
	    Symbol* symbol_object = new Symbol(identifier, object);
	    symbol_table.push_back(symbol_object);
	    return move(object);
	}
	
	static Expression* parseAdd(Expression* lhs, char operator_, Expression* rhs){
	    auto object = new Add(lhs, operator_, rhs);
	    cout << "[NODE] ADD node created at " << object << ". LHS is at " << lhs << ". RHS is at " << rhs << "\n";
	    return move(object);
	}

	static Expression* parseSub(Expression* lhs, char operator_, Expression* rhs){
	    auto object = new Sub(lhs, operator_, rhs);
	    cout << "[NODE] SUB node created at " << object << ". LHS is at " << lhs << ". RHS is at " << rhs << "\n";
	    return move(object);
	}
	
	static Expression* parseMultiply(Expression* lhs, char operator_, Expression* rhs){
	    auto object = new Multiply(lhs, operator_, rhs);
	    cout << "[NODE] MULTIPLY node created at " << object << ". LHS is at " << lhs << ". RHS is at " << rhs << "\n";
	    return move(object);
	}
	
	static Expression* parseDivide(Expression* lhs, char operator_, Expression* rhs){
	    auto object = new Divide(lhs, operator_, rhs);
	    cout << "[NODE] DIVIDE node created at " << object << ". LHS is at " << lhs << ". RHS is at " << rhs << "\n";
	    return move(object);
	}
	
	static Expression* parseAssignment(Expression* lvalue, Expression* rvalue){
	    auto object = new Assignment(lvalue, rvalue);
	    cout << "[NODE] ASSIGNMENT node created at " << object << ". lvalue is located at " << lvalue << ". rvalue is located at " << rvalue << endl;
        return move(object);
	}

    static Expression* parseNegation(Expression* lvalue){
        auto object = new Negate(lvalue);
        cout << "[NODE] NEGATION node created at " << object << ". lvalue is located at " << lvalue << endl;
        return move(object);
    }
    
    static Expression* parseOR(Expression* lhs, Expression* rhs){
        auto object = new OR(lhs, rhs);
        cout << "[NODE] OR node created at " << object << ". lhs is at " << lhs << ". rhs is at " << rhs << endl;
        return move(object); 
    }

    static Expression* parseAND(Expression* lhs, Expression* rhs){
        auto object = new AND(lhs, rhs);
        cout << "[NODE] AND node created at " << object << ". lhs is at " << lhs << ". rhs is at " << rhs << endl;
        return move(object); 
    }


    static Expression* parseNOT(Expression* rhs){
        auto object = new NOT(rhs);
        cout << "[NODE] NOT node created at " << object << ". rhs is " << rhs << endl;
        return move(object);
    }   
    
    static Expression* parseEquality(Expression* lhs, Expression* rhs){
        auto object = new EQUALITY(lhs, rhs);
        cout << "[NODE] EQUALITY node created at " << object << ". lhs is " << lhs << ". rhs is " << rhs << endl;
        return object;
    }
    
    static Expression* parseLessThan(Expression* lhs, Expression* rhs){
        auto object = new LESS_THAN(lhs, rhs);
        cout << "[NODE] LESS THAN node created at " << object << ". lhs is at " << lhs << ". rhs is at " << rhs << endl;
        return object;
    }
    
    static Block* parseIf(Statement* condition, Block* if_statements, Block* else_statements){
        auto object = new IF_BLOCK(condition, if_statements, else_statements);
        cout << "[BLOCK] IF BLOCK created at " << object << ". condition at " << condition << ". if statements block at " << if_statements << ". else statements block at " << else_statements << endl;
        return object;
    }
    
    static Block* parseWhile(Statement* condition, Block* while_statements){
        auto object = new WHILE_BLOCK(condition, while_statements);
        cout << "[BLOCK] WHILE block created at " << object << ". condition at " << condition << ". while statement list at " << while_statements << endl;
        return object;
    }
    
    static Block* parseFor(Block* assign, Statement* condition, Block* update, Block* for_statements){
        auto object = new FOR_BLOCK(condition, assign, update, for_statements);
        cout << "[BLOCK] FOR block created at " << object << ". condition at " << condition << ". assign statements at " << assign << ". update statements at " << update << ". for statement list at " << for_statements << endl;
        return object;
    }
    
       
    

%}

%union{
	char* id;
	char* string_literal;
	int integer_value;
	double real_value;
	int other_token_int;
	Expression* expression;
	Statement* statement;
	Block* block;
}

%token	<integer_value> 	INTEGER_CONSTANT
%token	<real_value> 		REAL_CONSTANT
%token	<other_token_int> 	KEYWORD_IF
%token  <other_token_int>	KEYWORD_ELSE
%token  <other_token_int>	KEYWORD_PRINTF
%token  <other_token_int>	KEYWORD_DTYPE_INT
%token  <other_token_int>	KEYWORD_DTYPE_DOUBLE
%token  <other_token_int>	KEYWORD_DTYPE_FLOAT
%token  <other_token_int>	KEYWORD_FOR
%token  <other_token_int>	KEYWORD_WHILE
%token  <other_token_int>	KEYWORD_DO
%token  <other_token_int>	SEPARATOR_COMMA
%token  <id>			    IDENTIFIER
%token  <other_token_int>	SEPARATOR_SEMICOLON
%token  <other_token_int>	OPERATOR_EQUAL
%token  <other_token_int>	OPERATOR_OR
%token  <other_token_int>	OPERATOR_NOT
%token  <other_token_int>	LEFT_PARAN
%token  <other_token_int>	RIGHT_PARAN
%token  <other_token_int>	LEFT_CURLY
%token  <other_token_int>	RIGHT_CURLY
%token  <other_token_int>	OPERATOR_DOUBLE_EQUAL
%token  <other_token_int>	OPERATOR_LESS_THAN
%token  <other_token_int>	OPERATOR_GREATER_THAN
%token  <other_token_int>	OPERATOR_AND
%token  <other_token_int>	OPERATOR_SUB
%token  <other_token_int>	OPERATOR_MULTIPLY
%token  <other_token_int>	OPERATOR_DIVIDE
%token  <string_literal>	STRING


%left OPERATOR_AND
%left OPERATOR_OR
%left OPERATOR_SUB OPERATOR_ADD
%left OPERATOR_NOT

%type <expression> EXPRESSION EXPRESSION_STATEMENT
%type <block> BASIC_BLOCKS BEGIN STATEMENT_LIST PROGRAM IF_BLOCK WHILE_BLOCK DO_WHILE_BLOCK FOR_ASSIGN FOR_UPDATE FOR_BLOCK

%start PROGRAM

%%

PROGRAM: BASIC_BLOCKS {
    master_block = $1;
    printf("--------------------------\nMaster block stored at: %x\n", master_block); // should print out a valid address
    printf("Printing the AST nodes now: \nMaster AST - ");
    master_block->debug();
    cout << endl;
    for(Statement* statement : master_block->block_statements){
        
        if(statement->operation == "IF BLOCK"){
            Block* temp = (Block*)statement;
            cout << "\n[IF BLOCK BREAKDOWN] ";
            temp->debug();
        }
        
        else if(statement->operation == "WHILE BLOCK"){
            Block* temp = (Block*)statement;
            cout << "\n[WHILE BLOCK BREAKDOWN] ";
            temp->debug();
        }
        
        else if(statement->operation == "DO WHILE BLOCK"){
            Block* temp = (Block*)statement;
            cout << "\n[DO WHILE BLOCK BREAKDOWN] ";
            temp->debug();
        }
        
        else if(statement->operation == "FOR BLOCK"){
            Block* temp = (Block*)statement;
            cout << "\n[FOR BREAKDOWN] ";
            temp->debug();
        }
    }
    
}
;

BASIC_BLOCKS: BEGIN	{

		$$ = new Block();
        for (Statement* statement : $1->block_statements)
		    $$->block_statements.push_back(statement);
		// $$->debug();
	}
	| BASIC_BLOCKS BEGIN {
	    
	    for (Statement* statement : $2->block_statements)
		    $1->block_statements.push_back(statement);
	    
	    //$$->debug(); 
	}
;

BEGIN: BEGIN IF_BLOCK{
           Statement* temp = $<statement>2;
           temp->operation = "IF BLOCK";
           $1->block_statements.push_back(temp);
        }
	| BEGIN WHILE_BLOCK 	{
	       Statement* temp = $<statement>2;
           temp->operation = "WHILE BLOCK";
           $1->block_statements.push_back(temp);
	    }
	| BEGIN DO_WHILE_BLOCK	{
	       Statement* temp = $<statement>2;
           temp->operation = "DO WHILE BLOCK";
           $1->block_statements.push_back(temp);
	    }
	| BEGIN FOR_BLOCK	{
	       Statement* temp = $<statement>2;
           temp->operation = "FOR BLOCK";
           $1->block_statements.push_back(temp);
	    }
	| BEGIN STATEMENT_LIST	{
	      for (Statement* statement : $2->block_statements)
	        $1->block_statements.push_back(statement);
	    }	
	| STATEMENT_LIST {
	    $$ = new Block();
	    for (Statement* statement : $1->block_statements)
	        $$->block_statements.push_back(statement);
	    //$$->debug();    
	}
	| {
	    $$ = new Block();
	  }
;

DO_WHILE_BLOCK:  KEYWORD_DO LEFT_CURLY STATEMENT_LIST RIGHT_CURLY KEYWORD_WHILE LEFT_PARAN EXPRESSION RIGHT_PARAN SEPARATOR_SEMICOLON {
                    $$ = parseWhile($<statement>7, $3); // it is so similar that I don't define a separate class
}
;

WHILE_BLOCK:	KEYWORD_WHILE LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY STATEMENT_LIST RIGHT_CURLY {
                    $$ = parseWhile($<statement>3, $6);
            }

;

FOR_BLOCK: KEYWORD_FOR LEFT_PARAN FOR_ASSIGN SEPARATOR_SEMICOLON EXPRESSION SEPARATOR_SEMICOLON FOR_UPDATE RIGHT_PARAN LEFT_CURLY STATEMENT_LIST RIGHT_CURLY	{
                    $$ = parseFor($3, $<statement>5, $7, $10);
}
;

FOR_ASSIGN:	FOR_ASSIGN SEPARATOR_COMMA DATATYPE EXPRESSION	{
                    $1->block_statements.push_back($<statement>4);
            }
		| DATATYPE EXPRESSION	{
		            $$ = new Block();
		            $$->block_statements.push_back($<statement>2);
		}
		| {$$ = new Block();}
;


FOR_UPDATE:	FOR_UPDATE SEPARATOR_COMMA EXPRESSION	{
                    $1->block_statements.push_back($<statement>3); 
                }
		| EXPRESSION	{
		            $$ = new Block();
		            $$->block_statements.push_back($<statement>1);
		}
		| {$$ = new Block();}
;


IF_BLOCK:	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY STATEMENT_LIST RIGHT_CURLY	{

                           $$ = parseIf($<statement>3, $6, NULL);   
                           $$->debug();
                        }
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY STATEMENT_LIST RIGHT_CURLY KEYWORD_ELSE LEFT_CURLY STATEMENT_LIST RIGHT_CURLY {
	                       $$ = parseIf($<statement>3, $6, $10);
	                       $$->debug();
	}
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN EXPRESSION_STATEMENT	{
	                       Statement* temp_statement = $<statement>5;
	                       Block* temp_block = new Block();
	                       temp_block->operation = $5->operation;
	                       temp_block->block_statements.push_back(temp_statement);
	                       $$ = parseIf($<statement>3, temp_block, NULL);
	        }
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN EXPRESSION_STATEMENT KEYWORD_ELSE EXPRESSION_STATEMENT	{
	                       Statement* temp_statement = $<statement>5;
	                       Block* temp_block = new Block();
	                       temp_block->operation = $5->operation;
	                       temp_block->block_statements.push_back(temp_statement);
	                       
	                       Statement* temp_statement_2 = $<statement>7;
	                       Block* temp_block_2 = new Block();
	                       temp_block_2->operation = $7->operation;
	                       temp_block_2->block_statements.push_back(temp_statement_2);
	                       
	                       $$ = parseIf($<statement>3, temp_block, temp_block_2);
	        }
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY STATEMENT_LIST RIGHT_CURLY KEYWORD_ELSE EXPRESSION_STATEMENT {

                           Statement* temp_statement = $<statement>9;
	                       Block* temp_block = new Block();
	                       temp_block->operation = $9->operation;
	                       temp_block->block_statements.push_back(temp_statement);
	                       
	                       $$ = parseIf($<statement>3, $6, temp_block);
	        }
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY BEGIN RIGHT_CURLY {
	                            
	                        $$ = parseIf($<statement>3, $6, NULL);
	        }
	|	KEYWORD_IF LEFT_PARAN EXPRESSION RIGHT_PARAN LEFT_CURLY BEGIN RIGHT_CURLY KEYWORD_ELSE LEFT_CURLY BEGIN RIGHT_CURLY {
	                       $$ = parseIf($<statement>3, $6, $10);
	                        
	 }
;

STATEMENT_LIST:	STATEMENT_LIST EXPRESSION_STATEMENT {
                    $1->block_statements.push_back($<statement>2);
                    // $1->debug();
            }
	|	EXPRESSION_STATEMENT {
	        $$ = new Block();
	        $$->block_statements.push_back($<statement>1);
	        // $1->debug();
	    }
	|   {}
;

EXPRESSION_STATEMENT:	EXPRESSION OPERATOR_EQUAL EXPRESSION SEPARATOR_SEMICOLON 	{
		
		    $$ = parseAssignment($1, $3);
		    $$->debug();
		}
		| DATATYPE EXPRESSION OPERATOR_EQUAL EXPRESSION SEPARATOR_SEMICOLON {
		    $$ = parseAssignment($2, $4);
		    $$->debug();
		}
;

DATATYPE: KEYWORD_DTYPE_INT {}
	| KEYWORD_DTYPE_FLOAT {}
	| KEYWORD_DTYPE_DOUBLE {}
	| {}
;


EXPRESSION:	IDENTIFIER {
            string ID = $1;
            $$ = parseIdentifier(ID);
            $$->debug();
        }
	|	INTEGER_CONSTANT	{
			$$ = parseIntegers($1); 
			$$->debug(); // should this be working fine, the pointers are decent enough
		}
	| 	REAL_CONSTANT		{
			$$ = parseReals($1);
			$$->debug(); // check if working fine
		}
	|	EXPRESSION OPERATOR_ADD EXPRESSION {
	        $$ = parseAdd($1, '+', $3);
	        $$->debug();
	}
	| 	EXPRESSION OPERATOR_SUB EXPRESSION {
	    	$$ = parseSub($1, '-', $3);
	        $$->debug();
	}
	|	EXPRESSION OPERATOR_MULTIPLY EXPRESSION {
	        $$ = parseMultiply($1, '*', $3);
	        $$->debug();
	}
	|	EXPRESSION OPERATOR_DIVIDE EXPRESSION {
	        $$ = parseDivide($1, '/', $3);
	        $$->debug();
	}
	|	OPERATOR_SUB	EXPRESSION		{
	        $$ = parseNegation($2);
	        $$->debug();
	}
	|	LEFT_PARAN EXPRESSION RIGHT_PARAN	{
	        $$ = move($2);
	        cout << "[DEBUG] Paranthesis expression encouted. Simply floating node address\n";
	}
	
	|   EXPRESSION OPERATOR_OR EXPRESSION	{
            $$ = parseOR($1, $3);
            $$->debug();
    }
    
    |   EXPRESSION OPERATOR_AND EXPRESSION	{
            $$ = parseAND($1, $3);
            $$->debug();
    }
    
    |   OPERATOR_NOT EXPRESSION	{
            $$ = parseNOT($2);
            $$->debug();
    }
    
    
    | EXPRESSION OPERATOR_DOUBLE_EQUAL EXPRESSION {
            $$ = parseEquality($1, $3);
            $$->debug();
    }
	|	EXPRESSION OPERATOR_LESS_THAN EXPRESSION	{
	        $$ = parseLessThan($1, $3);
	        $$->debug();
	}
	|	EXPRESSION OPERATOR_GREATER_THAN EXPRESSION	{
	        $$ = parseLessThan($3, $1);
	        $$->debug();	        
	}
	
	|   LEFT_PARAN EXPRESSION OPERATOR_DOUBLE_EQUAL EXPRESSION RIGHT_PARAN {
	        $$ = parseEquality($2, $4);
            $$->debug();
	    }
	|   LEFT_PARAN EXPRESSION OPERATOR_LESS_THAN EXPRESSION RIGHT_PARAN{
	        $$ = parseLessThan($2, $4);
	        $$->debug();
	}

	|   LEFT_PARAN EXPRESSION OPERATOR_GREATER_THAN EXPRESSION RIGHT_PARAN{
	        $$ = parseLessThan($4, $2);
	        $$->debug();
	}
	
	|   EXPRESSION OPERATOR_EQUAL EXPRESSION {
		
		    $$ = parseAssignment($1, $3);
		    $$->debug();
	}
	|    DATATYPE EXPRESSION OPERATOR_EQUAL EXPRESSION SEPARATOR_SEMICOLON {
		    $$ = parseAssignment($2, $4);
		    $$->debug();
	}
    
;

%%


int main(){
	yyin = fopen("program.c", "r");
	if(yyparse()){
		printf("Erroraneous code. Frontend exited");
	}
	cout << "\n------------------------- SYMBOL TABLE------------------------" << endl;
	cout << "Symbol \t\t Memory" << endl;
	for (Symbol* symbol : symbol_table){
	    
	    cout << symbol->identifier << "\t\t" << symbol->identifier_node << endl;
	
	}
}
