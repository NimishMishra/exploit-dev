%{
	#include "classdef.h"
	#include "parser.hpp"
	#include <stdlib.h>
	#include <stdio.h>	
%}


%option noyywrap
%option yylineno
whitespace [ \t\n]+
digit [0-9]
integer {digit}+
exponent [eE][+-]?{integer}
real	{integer}("."{integer})?{exponent}?

%%

"//".*\n	{//ignore single line comment
		}
{whitespace}	{//ignore whitespace
		}
{integer}		{
	yylval.integer_value = atoi(yytext);
	return INTEGER_CONSTANT;
}
{real}	{
	yylval.real_value = atof(yytext);
	return REAL_CONSTANT;
}
"if"	{return KEYWORD_IF;}
"else"	{return KEYWORD_ELSE;}
"printf"	{return KEYWORD_PRINTF;}
"int"	{return KEYWORD_DTYPE_INT;}
"float"	{return KEYWORD_DTYPE_FLOAT;}
"double" {return KEYWORD_DTYPE_DOUBLE;}
"for"	{return KEYWORD_FOR;}
"while"	{return KEYWORD_WHILE;}
"do"	{return KEYWORD_DO;}
","	{return SEPARATOR_COMMA;}
[_a-zA-Z][_a-zA-Z0-9]*	{
				yylval.id = (char*) strdup(yytext);
				return IDENTIFIER;
}

";"	{return SEPARATOR_SEMICOLON;}
"=="	{return OPERATOR_DOUBLE_EQUAL;}
"="	{return OPERATOR_EQUAL;}
"||"	{return OPERATOR_OR;}
"|"	{return OPERATOR_OR;}
"!"	{return OPERATOR_NOT;}
"("	{return LEFT_PARAN;}
")"	{return RIGHT_PARAN;}
"{"	{return LEFT_CURLY;}
"}"	{return RIGHT_CURLY;}
"<"	{return OPERATOR_LESS_THAN;}
">"	{return OPERATOR_GREATER_THAN;}
"&&"	{return OPERATOR_AND;}
"&"	{return OPERATOR_AND;}
"+"	{return OPERATOR_ADD;}
"-"	{return OPERATOR_SUB;}
"*"	{return OPERATOR_MULTIPLY;}
"/"	{return OPERATOR_DIVIDE;}
"\"[a-zA-Z]*\""	{
				yylval.string_literal = (char*) strdup(yytext);
				return STRING;
}
.	{printf("%s: lexical error", yytext);}
%%
