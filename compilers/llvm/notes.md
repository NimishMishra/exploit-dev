# General notes on LLVM

- Generic workflow: Clang AST -> LLVM IR -> Selection DAG -> LLVM MIR -> Machine code

`clang`: source code <--> LLVM IR

`llc`: LLVM IR <--> LLVM MIR <--> Machine code

- `opt` optimized LLVM IR. `llc` optimizes LLVM MIR. Recall that little `-O3` in clang to give a level of optimization you are targetting.

- LLVM interally uses a control flow graphs (basic blocks and control flow edges). The idea of basic blocks isn't completely true, because you could have things that abort execution, so the basic block won't get executed completely. The rule of thumb could be that no statement in a basic block 

- LLVM is always in SSA form, with inifinite registers

- LLVM function stub

```c++
define dso_local i64 @f(i64 %a, i64 %b) #0{

entry:
	%cmp = icmp sgt i64 %a, %b
	br i1 %cmp, label %if.then, label %if.else

if.then:
	%add = add nsw i64 %a, 20
	br label %if.end
if.else:
	%addl = add nsw i64 %a, %b
	br label %if.end

if.end:
	%x.0 = phi i64 [%add, %if.then], [%addl, %if.else]
	ret i64 %x.0

}

attributes #0 = { nounwind uwtable }
```
So it basically takes two 64 bits arguments and returns on 64 bit argument. Attributes:

- nounwind: not throw an exception and unwind to stack

- nsw: no sign wrap (sign numbers are not allowed to wrap)

- entry simply has a boolean result i1 and it jumps based on the value of that result

- if.end has a PHI function, which can be recalled as a generic tool you use in single static assignment. Since `x` can't be assigned twice, PHI lets you use the value of x based on whatever path the computation took.

- LLVM has to be **well-formed** for all **basic blocks** reachable from the entry/root. The remaining is dead-code, because LLVM doesn't really care about dead-code

## LLVM hierarchy

- llvm::Module
	- llvm::GlobalVariable (start with a @)
	- llvm::Function
		- llvm::BasicBlock
			- llvm::LocalVariable (start with a %)
			- llvm::Instruction
				- llvm::ICmpInst
				- llvm::BranchInst
	- llvm::Constant

- Since LLVM follows SSA, everything is constant in LLVM IR. Note however, this doesn't mean the address is known at compile-time. It just means once assigned an address, they will remain thus.

- Basic block names start with % when used. And end with : when defined

## LLVM-IR

- %sum = add i32 4, %var ; sum = var + 4 (as 32 bit numbers)

- %cmp = icmp sge i32 %a, %b ; store the result of  a>=b in cmp

- %value = load i32 i32* %ptr ; load a 32 bit value from a 32 bit pointer to %value

- store i32 %value, i32* ptr ; store a 32 bit value to an address pointed to by a 32 bit pointer

- br label %label-name ; branch to label label-name

- br i1 %cmp, label %true, label %false ; branch conditional on value of %cmp

- ret float %a

- %ret = call i32 @foo(i8* %arg1, i16 %atg2) ; call an anonymous function foo that returns a 32 bit value upon taking a 8 bit pointer and 16 bit value

- %x = PHI i64 [INST, LABEL], [INST, LABEL] ; Based on whichever control path was taken, give %x the value computed in INST. LABELS defined which two control paths are possible.


# Code generator

- Codegen

	- Instruction selection

	- Register allocation

	- Instruction scheduling

	- Machine IR

	- Machine optimizations

	- Machine specific features (stack protection etc)

	- Exception handling

- Targets

	- CPU targets, CPU pipeline, ABI
