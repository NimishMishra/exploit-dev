%{
    #include <stdio.h>
    #include <math.h>
    #include <stdlib.h>
    extern int yylineno;

    extern FILE* yyin;
    #define YYDEBUG 1
    extern int lineNum;

    int tempIndex = 0;
    int if_else_index = 0;
    char code[30];
    char str[6];
    char tempName[20];
    char variableName[5];

    char else_start_label[20];
    char else_end_label[20];

    char E_code[1000];
    char loop_condition_code[100];
    char loop_update_code[100];

    char* returnTempName(){
        
        memset(str, '\0', 6);
        memset(tempName, '\0', 20);
        sprintf(str, "%d", tempIndex);
        tempIndex++;
        strcat(tempName, "$t");
        strcat(tempName, str);
        return strdup(tempName);
    }

    char* returnElseStartLabel(){
        memset(str, '\0', 6);
        memset(tempName, '\0', 20);
        sprintf(str, "%d", if_else_index);
        strcat(tempName, "ELSE_START_");
        strcat(tempName, str);
        return strdup(tempName);
    }

    char* returnElseEndLabel(){
        memset(str, '\0', 6);
        memset(tempName, '\0', 20);
        sprintf(str, "%d", if_else_index);
        strcat(tempName, "ELSE_END_");
        strcat(tempName, str);
        if_else_index++;
        return strdup(tempName);
    }

%}

%union{
    char* id;
    int integer;
    char* code;
    int integer_value;
}

%expect 5

%token <integer_value> IC
%token <integer> FC
%token <integer> KEYWORD_IF
%token <integer> KEYWORD_ELSE
%token <integer> KEYWORD_PRINT
%token <integer> INT
%token <integer> REAL
%token <id> ID
%token <integer> EQUAL
%token <integer> SEMICOLON
%token <integer> STR
%token <integer> OR
%token <integer> AND
%token <integer> NOT
%token <integer> LEFT_PARAN
%token <integer> RIGHT_PARAN
%token <integer> DOUBLE_EQUAL
%token <integer> LESS_THAN
%token <integer> GREATER_THAN
%token <integer> ADD
%token <integer> SUB
%token <integer> MUL
%token <integer> DIVIDE
%token <integer> LEFT_CURLY
%token <integer> RIGHT_CURLY 
%token <integer> FOR
%token <integer> COMMA
%token <integer> WHILE
%token <integer> KEYWORD_DO

%left AND
%left OR
%left SUB ADD
%left DIVIDE MUL
%left NOT   

%type <code> E P IF_BLOCK SL S BE RE FOR_BLOCK FOR_ASSIGN FOR_UPDATE FOR_ASSIGN_STATEMENT LOOP_BE LOOP_RE WHILE_BLOCK
%start P
%%

P: P IF_BLOCK {}
    | P FOR_BLOCK {}
    | P WHILE_BLOCK {}
    | P DO_WHILE_BLOCK {}
    |   {}
;

DO_WHILE_BLOCK: SL KEYWORD_DO LEFT_CURLY SL RIGHT_CURLY WHILE LEFT_PARAN {char* label = returnElseStartLabel(); if_else_index++; strcpy(else_start_label, label); strcat(E_code, else_start_label); strcat(E_code, ": ");} LOOP_BE RIGHT_PARAN SEMICOLON {
     
    printf("%s", E_code);
    printf("%s", loop_condition_code);
    memset(E_code, '\0', strlen(E_code));
    memset(loop_condition_code, '\0', strlen(loop_condition_code));
}

;

WHILE_BLOCK: SL WHILE LEFT_PARAN {char* label = returnElseStartLabel(); if_else_index++; strcpy(else_start_label, label); strcat(E_code, else_start_label); strcat(E_code, ": ");} LOOP_BE RIGHT_PARAN LEFT_CURLY SL RIGHT_CURLY {
        printf("%s", E_code);
        printf("%s", loop_condition_code);
        memset(E_code, '\0', strlen(E_code));
        memset(loop_condition_code, '\0', strlen(loop_condition_code));
    }
;

FOR_BLOCK: FOR LEFT_PARAN FOR_ASSIGN SEMICOLON {char* label = returnElseStartLabel(); if_else_index++; strcpy(else_start_label, label); strcat(E_code, else_start_label); strcat(E_code, ": ");} LOOP_BE SEMICOLON FOR_UPDATE RIGHT_PARAN LEFT_CURLY SL RIGHT_CURLY {
    printf("%s", E_code);
    printf("%s", loop_update_code);
    printf("%s", loop_condition_code);
    memset(E_code, '\0', strlen(E_code));
    memset(loop_condition_code, '\0', strlen(loop_condition_code));
    memset(loop_update_code, '\0', strlen(loop_update_code));

}
;
FOR_ASSIGN: FOR_ASSIGN COMMA FOR_ASSIGN_STATEMENT {}
    | FOR_ASSIGN_STATEMENT

;
FOR_ASSIGN_STATEMENT: ID EQUAL IC {
        memset(code, '\0', 30);
        memset(str, '\0', 6);
        sprintf(str, "%d", $3);
        strcat(code, "addi ");
        strcat(code, $1);
        strcat(code, ", $zero, ");
        strcat(code, str);
        strcat(code, "\n");
        strcat(E_code, code);
    }
;

FOR_UPDATE: FOR_UPDATE COMMA FOR_UPDATE_STATEMENT {}
    | FOR_UPDATE_STATEMENT {}

;
FOR_UPDATE_STATEMENT: ID ADD EQUAL IC {
        memset(code, '\0', 30);
        memset(str, '\0', 6);
        sprintf(str, "%d", $4);
        strcat(code, "addi ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, str);
        strcat(code, "\n");
        strcat(loop_update_code, code);
    }
;

IF_BLOCK: KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN LEFT_CURLY SL RIGHT_CURLY IF_END ELSE_END
    {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN LEFT_CURLY SL RIGHT_CURLY IF_END KEYWORD_ELSE LEFT_CURLY SL RIGHT_CURLY ELSE_END {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }

    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN S IF_END ELSE_END {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN S IF_END KEYWORD_ELSE LEFT_CURLY SL RIGHT_CURLY ELSE_END
    {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN S IF_END KEYWORD_ELSE S ELSE_END
    {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN LEFT_CURLY SL RIGHT_CURLY IF_END KEYWORD_ELSE S ELSE_END {
        printf("%s\n", E_code);
        memset(E_code, '\0', strlen(E_code));
    }
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN LEFT_CURLY P RIGHT_CURLY IF_END ELSE_END {}
    | KEYWORD_IF LEFT_PARAN BE RIGHT_PARAN LEFT_CURLY P RIGHT_CURLY IF_END KEYWORD_ELSE LEFT_CURLY SL RIGHT_CURLY ELSE_END {}

;

IF_END: {
    char* label = returnElseEndLabel();
    strcpy(else_end_label, label);
    strcat(E_code, "j ");
    strcat(E_code, else_end_label);
    strcat(E_code, "\n");
    strcat(E_code, else_start_label);
    strcat(E_code, ": ");
}
;

ELSE_END: {
    strcat(E_code, else_end_label);
    strcat(E_code, ": ");
}
;

SL: SL S  {}
    | S {}
;

S: E EQUAL E SEMICOLON {
    memset(code, '\0', 30);
    strcat(code, "add ");
    strcat(code, $1);
    strcat(code, ", $zero, ");
    strcat(code, variableName);
    strcat(code, "\n");
    strcat(E_code, code);
}
;

LOOP_BE: LOOP_BE OR LOOP_BE {}
    | LOOP_BE AND LOOP_BE {}
    | NOT LOOP_BE {}
    | LEFT_PARAN LOOP_BE RIGHT_PARAN {}
    | LOOP_RE {}
;

LOOP_RE: E DOUBLE_EQUAL E {
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $3);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, "\n");
        strcat(code, "jne ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(loop_condition_code, code);
}
    | E LESS_THAN E {
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $3);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, "\n");
        strcat(code, "jl ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(loop_condition_code, code);
    }
    | E GREATER_THAN E {
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(code, "jl ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(loop_condition_code, code);
    }
;

;

BE: BE OR BE {}
    | BE AND BE {}
    | NOT BE {}
    | LEFT_PARAN BE RIGHT_PARAN {}
    | RE {}
;

RE: E DOUBLE_EQUAL E {
        char* label = returnElseStartLabel();
        strcpy(else_start_label, label);
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $3);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, "\n");
        strcat(code, "jne ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(E_code, code);
}
    | E LESS_THAN E {
        
        char* label = returnElseStartLabel();
        strcpy(else_start_label, label);
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $3);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, "\n");
        strcat(code, "jl ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(E_code, code);
    }
    | E GREATER_THAN E {
        char* label = returnElseStartLabel();
        strcpy(else_start_label, label);
        memset(code, '\0', 30);
        strcat(code, "cmp ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(code, "jl ");
        strcat(code, else_start_label);
        strcat(code, "\n");
        strcat(E_code, code);
    }
;

E:   ID {}
    | IC {}
    | FC {}
    | E ADD E {
        memset(code, '\0', 30);
        char* varName = returnTempName();
        strcat(code, "add ");
        strcat(code, varName);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(E_code, code);
        strcpy(variableName, varName);
        }
    | E SUB E {
        memset(code, '\0', 30);
        char* varName = returnTempName();
        strcat(code, "sub ");
        strcat(code, varName);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(E_code, code);
        strcpy(variableName, varName);
    }
    | E MUL E {
        memset(code, '\0', 30);
        char* varName = returnTempName();
        strcat(code, "mul ");
        strcat(code, varName);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(E_code, code);
        strcpy(variableName, varName);
    }
    | E DIVIDE E {
        memset(code, '\0', 30);
        char* varName = returnTempName();
        strcat(code, "div ");
        strcat(code, varName);
        strcat(code, ", ");
        strcat(code, $1);
        strcat(code, ", ");
        strcat(code, $3);
        strcat(code, "\n");
        strcat(E_code, code);
        strcpy(variableName, varName);
    }
    | SUB E {
        memset(str, '\0', 6);
        memset(code, '\0', 30);
        char* varName = returnTempName();
        strcat(code, "addi ");
        strcat(code, varName);
        strcat(code, ", $zero, ");
        sprintf(str, "%d", $2);
        strcat(code, str);
        strcat(code, "\n");
        strcat(code, "subu ");
        strcat(code, $$);
        strcat(code, ", $zero, ");
        strcat(code, varName);
        strcat(code, "\n");
        strcat(E_code, code);
        //flag = 0;
    }
    | LEFT_PARAN E RIGHT_PARAN {}
;

%%
 
int yyerror (char* s){
    printf("%s in line %d\n", s, yylineno);
}

int main(){
    printf("Starting parsing: \n");
    yyin = fopen("sample_prog.txt", "r");
    //yydebug = 1 ;
    memset(E_code, '\0', strlen(E_code));
    memset(loop_condition_code, '\0', strlen(loop_condition_code));
    memset(loop_update_code, '\0', strlen(loop_update_code));
    if(!yyparse()){
        printf("\nAccept \n");
    }

    else{
        printf("Erroraneous code\n");
    }
}