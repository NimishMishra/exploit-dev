# Reversing

- **Forward engineering** is when you take a systems design, write code, compile it, and assemble it. At each step, information is lost. Reverse engineering tries to get that lost information lost.

- The highest data loss is during compilation. Entire function names, variable names, structures/classes, type information, comments are lost. Moreover, compiler optimizations remove entire algorithms from final binary. The `-g` flag prevents this information loss.

- Run the gcc preprocessor: `cpp filename.c`. Run the compilation: `gcc -S -masm=intel filename.c`. Strip the final binary of metadata: `strip filename_binary`.

- Hierarchy: program --> modules --> functions --> blocks --> instructions --> data. Mostly, the main module would be relying on extenal libraries; their functionalities would be well-documented in most of the cases. Functions can usually be reverse-engineered in isolation. Each function would be containing a control-flow graph of its basic blocks.

- Functions start by setting up the stack frame and end by tearing down the stack frame. Information that is managed when a function is called: `rip` (the address of the next instruction from where to continue from once the function execution is done), the stack frame (the `rbp` [points to the uppermost side of the stack frame, or the address **from** where you can begin inserting data] and the `rsp` [points to the bottom side of the stack frame, or the address **till** where you have inserted data]). Destroying the stack frame then is simply a `mov rsp, rbp`.

- `-fomit-frame-pointer`: Do not use `rbp` to set up the stack.

- Regions of data: **.data** (pre-initialized global writable data), **.rodata** (global read-only data), **.bss** (unintialized global writable data), static, heap.

- **Stack**: access data based on push/pop, based on rsp based addresses, or based on rbp based addresses.

- All other data (.data, .rodata, .bss) are stored at known offsets in the ELF. Use rip-relative instructions to access such data.

## Static tools

- katai, nm, strings, objdump, checksec, binary ninja, IDA pro, ghidra

## Dynamic tools

- ltrace, strace. gdb

- gdb tries to load PIE (position independent executables) at fixed locations, to technically help reversing. Use `$base` to this effect.

- **Timeless execution**: gdb can also record and rewind execution trace. Can use `rr` or `qira`.

## Levels

### Level 1

A static 5 byte license-key is used to compare authenticity of the binary. Static licenses are a problem: you can directly extract and use them.
