# Practice object files

- [LiveOverFlow](https://github.com/LiveOverflow/liveoverflow_youtube)

    - license_1
    - license_2

## Stack overflow

Naturally, OSes are vigilant against stack overflows, so it's difficult to observe them as it is. Thus, the binary must be made with special flags:

**gcc -no-pie -fno-stack-protector -o stack_demonstration stack_demonstration.c**

**-no-pie**: generates an executable without the Global Offset Table. Without this, the functions will be randomly put in the virtual memory, and exploitation PoC will be tough.

**-fno-stack-protector**: Disables canaries, or stack protector that know when the stack is modified.

**gcc -mpreferred-stack-boundary=3 -ggdb stack_demonstration.c -o stack_demonstration**

*GDB*: can easily inject bytes as **run $(python3 -c "print('AAAAAAAAAAAAAAAAAAAAAAAA\xf8\x51\x55\x55\x55\x55');")**


## Breaking license_2

The key is not explicitly in the object file. So fire up radare2, and disassemble `main`. Open `VV` to get the visual map running. The main point being:

```s
cmp dword [var_18h], 0x394
```

which branches to `Access Granted!` if true and `WRONG!` if false. Converting this hex value to decimal (use python interpreter, enter 0x394 and simply press enter to get decimal 916), 916 is the decimal value. So something is getting compared to `916` to decide the branches.

### Forcing particular flow of execution (overwriting registers)

Consider the following disassembly:

```s
0x00400642      817de8940300.  cmp dword [var_18h], 0x394
0x00400649      750c           jne 0x400657
0x0040064b      bf1a074000     mov edi, str.Access_Granted ; 0x40071a ; "Access Granted!"
```

The following steps force the flow of execution by forcing the instruction pointer to be something we exactly want it to be:

- `r2 -d license_2` to start radare in debug mode 

- `db 0x00400649` to enter a breakpoint

- `ood INPUT_STRING` to begin execution. It will stop with `rip=0x00400649`

- Check status of the registers using `dr`

- Set value of `rip` using `dr rip=0x0040064b` to force `rip` to print the affected thing without being the correct key.

### Reversing a piece of code

The following piece of code is for what?

```s
0x00400604      488b45d0       mov rax, qword [var_30h]     <-- load an variable into  rax
0x00400608      4883c008       add rax, 8                   <-- add 8 to rax (which is intuitive since 64 bit architecture)
0x0040060c      488b10         mov rdx, qword [rax]         <-- load the actual value into rdx
0x0040060f      8b45ec         mov eax, dword [var_14h]     <-- Get another variable into eax
0x00400612      4898           cdqe    
0x00400614      4801d0         add rax, rdx                 <-- add contents of rax and rdx (sort of Indexing)
0x00400617      0fb600         movzx eax, byte [rax]        <-- get a BYTE (and only a character has a BYTE)
0x0040061a      0fbec0         movsx eax, al
0x0040061d      0145e8         add dword [var_18h], eax
0x00400620      8345ec01       add dword [var_14h], 1       <-- increment variable by 1 (a counter???)
```

This is a `for` loop of the following sort:

```C
for(int i = 0; i < SOMETHING; i++){

}
```

So we have the location of an array in memory. We load the address of the array (or in case of `int a[5]`, `a` is the address) into `rax`. We add 8 to `rax` to move to the second position in the array (which is the starting of our string that is being operated upon in the for loop here). `So basically, (rax+8) is the start of the string that we need to operate upon`. Upon loading `[rax]` to `rdx`, we load the memory location of the starting character of the string. Note `rax` has value X which actually points to memory Y. Loading `mov rdx, qword [rax]` means loading `Y` into `rdx`. Now, `eax` simply gets an integer counter to it. It is added to the memory location in `edx` to access contents of the string. Loading `BYTE` into `eax` is simply loading characters into the `eax`. And then we are summing up those characters in the variable `var_18h`.

- The difference between `rax` and `rdx` is precisely the difference between `a` and `a[0]`.

From our previous thinking, `0x00400642      817de8940300.  cmp dword [var_18h], 0x394` is comparing `var_18h` to 916. Hence, we are actually taking input a string, summing it up, and if it equals 916, we say access granted. 

### Crafting a payload

Just a string that sums up to `916`: `aaaaaaaaFF` (any stuff would work). We break the license program.