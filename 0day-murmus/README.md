# 0day Murmus CTF streams retracing

- Trying to retrace Murmus CTF 0day vulnerability research streams to probably think about my own methodology

## Radare 

Check out the [playlist](https://www.youtube.com/watch?v=SEGPkc8Pu84)

### What we doing?

- One of the best places to look for memory corruption bugs is where `binary parsing` happens and radare does a lot of binary parsing through a lot of formats, so more chances of bugs cropping up.

### Set up the environment

- Pull the Ubuntu docker image: `sudo docker pull ubuntu`

- Open the environment: `sudo docker run -it ubuntu`

- Make a copy of the clean environment:

	- While in the container, grab the container ID through `docker ps`

	- Commit with `docker commit <containerID> <newImageName>`

	- All other work now begins with `docker run -it <newImageName>`

- Building an image backup: `docker save radare2_testing > /home/manwe/Desktop/image.tar`

- Load the image from tar: `docker load < image.tar` and give decent name `docker image tag <oldname>:<oldtag>  <newname>:<newtag>`

### Build the target

- Before building radare2, install `make`, `gcc`

- Clone the repo: `git clone https://github.com/radareorg/radare2.git` and build radare normally. Check if it is working just fine.

- Check if the target is running fine: `rabin2` in this case.

### Build AFLPlusPlus

- `apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools`

- `sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang `

- `sudo apt-get install -y gcc-$(gcc --version|head -n1|sed 's/.* //'|sed 's/\..*//')-plugin-dev libstdc++-$(gcc --version|head -n1|sed 's/.* //'|sed 's/\..*//')-dev`

- `git clone https://github.com/AFLplusplus/AFLplusplus.git`

- `make distrib`

- `make install`

### Build radare with instrumentation

- Edit `radare2/sys/afl.sh` and update `export CC="afl-clang"` to `export CC="/home/radare2_testing/AFLplusplus/afl-clang-fast"` just in case `afl-clang-fast` is not well built

- Build radare with instrumentation: `./sys/afl.sh`

### Fuzz run 1

- Initialize `i` (inputs) and `o` (outputs)

- A very simple test case `AAAA` as `1` inside `i`

- Run the fuzzer: `afl-fuzz -i i -o o rabin2 - I @@`

	- Issue 1: `Radamsa is now a custom mutator, please use that (custom_mutators/radamsa/).` So go to `AFLPlusPlus/custom_mutators/radamsa` and `make` it. Then set `AFL_CUSTOM_MUTATOR_LIBRARY=/home/radare2_testing/AFLplusplus/custom_mutators/radamsa/radamsa-mutator.so`

	- Issue 2: The scaling governors in `/sys/devices/system/cpu/cpu*/cpufreq/scaling_governor` are set to powersave and AFL needs performance. But docker isn't allowing to change these, so we need to let go. So `export AFL_SKIP_CPUFREQ=1`

	- **Every new session needs the environment variables set up**. But they survive across different tmux sessions

And the thing starts!

### Setting corpus and parallelizing things

#### Setting up things

- `apt-get install tmux` and use tmux panes for clarity

- Every AFL instance uses 1 core. Check CPU cores in `/sys/devices/system/cpu` and see `cpu*`. I have 8. So probably will run 6 cores.

- After running a while, update the inputs: `cp o/default/queue/id\:0000* i/`

- Used inputs from `radareorg/radare2-fuzztargets`

- Change cpus to performance:

```s
cd /sys/devices/system/cpu
cat cpu*/cpufreq/scaling_governor    <---- shall give powersave
sudo echo performance | sudo tee ./cpu*/cpufreq/scaling_governor


;when done
sudo echo powersafe | sudo tee ./cpu*/cpufreq/scaling_governor

#### Minimise corpus

```
- Minimize corpus (run this **inside** the corpus directory with `min.sh` one level above). Minimization shall take a while

```s
for i in *;
do
        afl-tmin -i $i -o ../i/$i -- rabin2 -I @@
done
```

This runs fine but a [parallel version](https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/) is better

```s
#!/bin/bash

cores=$1
inputdir=$2
outputdir=$3
pids=""
total=`ls $inputdir | wc -l`

for k in `seq 1 $cores $total`
do
  for i in `seq 0 $(expr $cores - 1)`
  do
    file=`ls -Sr $inputdir | sed $(expr $i + $k)"q;d"`
    afl-tmin -i $inputdir/$file -o $outputdir/$file -- rabin2 -I @@ &
  done

  wait
done
```
And run it with `sh min.sh 6 ./old-inputs ./i`. Let it run. 


- After a while, I observed CPU consumption to be again uni-core. So I removed already done files and restarted the parallel process. Might wanna do a quick cleaning and restart the entire process:

```py
import os

g = os.listdir("./i")

for i in g:
	try:
		os.remove("./old-inputs/"+i)
	except:
		print("file already deleted probably...\n")
```

#### Fuzz

- Run instances:

	- **Main instance**: `afl-fuzz -i i -o o -M f1 -p exploit rabin2 - I @@`  

	- **Rest secondary**:
		
		- `afl-fuzz -i i -o o -S f2 -p coe rabin2 -I @@`

		- `afl-fuzz -i i -o o -S f3 -p rare rabin2 -I @@`

		- `afl-fuzz -i i -o o -S f4 -p explore rabin2 -I @@`
`
		- `afl-fuzz -i i -o o -S f5 -p lin rabin2 -I @@`

		- `afl-fuzz -i i -o o -S f6 -p fast rabin2 -I @@`

- After a decent while, do the following:

	- Minimise `/queue` of all fuzzers.

	- Resume fuzzing but now with `-i-` option to let inputs come from the queues.
