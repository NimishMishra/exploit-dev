# Embryoasm

## General pointers

To run a challenge:

1. Write assemly in a `.s` file

2. Compile with `gcc -nostdlib -static level1.s -o level1-elf`

3. Dump `.text` bytes with `objcopy --dump-section .text=level1 level1-elf`

4. Run `/challenge/embryoasm_level1 < level1`. If everything went right, there would be a flag displayed. Submit the flag and get points :)


## Assembly header

I like this header. So I keep it everywhere

```s
.global _start

_start:
.intel_syntax noprefix
```

## Generic notes

- [Instruction manual](https://www.felixcloutier.com/x86/)

- `imul` is signed multiplication and will allow you to choose source and destination registers. `mul` is unsigned and is limited to `rax` on x64 (and `eax` on x86)

- `div`  is unsigned divide wherein `rax` is divided by some register placing the quotient in `rax` and remainder in `rdx`. Division proceeds by taking the 128 bit register pair `rdx:rax` and divides it by the input register. This means it requires to zero out `rdx` before carrying out the operation/

- **Backward compatibility**: Design decisions were made to not allow backward compatability for any register other than `rax`, `eax`, `ax`, `al`/`ah` (why would you need lower bits of stack pointer, base pointer etc)

- Immediate operand makes a `mov` turn into `movabs`: `movabs  rax, 0xdeadbeef00001337`

- `mov     qword ptr [rdi], rax` means a `qword` is being moved to `ptr [rdi]` (or to the memory being pointed to by `rdi`)

- All offsets are in `bytes`.

- `jmp 0x400028` translates to opcode `e9` which is a relative near jump.

- `cmp` won't work with both dereferencing and immediate operands. Use registers in order to use dereferencing.

- None of the conditional jump instructions can take anything other than relative 8 bits, 16 bits, and 32 bits addresses.

- Be wary of hidden parameters. For example, `mul` wants a null `rdx` etc. Thereby, if you use `rdx` in computation, it might keep resetting to 0.

- x86 calling conventions keep arguments in registers. Like first argument is in `rdi` and so on. Return value is in `rax`.

- Doing `mov rdx, 0xAABBCCDD` will push in this value only. Doing the following will push this as a string:

```s
xor r10, r10
push r10
mov r11, 0xAABBCCDD
push r11
mov rdx, rsp
```

- Remember to end your shellcode with a `exit(0)` else the system will keep crying about SEGFAULTs

## Level 1

A simple register move: `mov rdi, 0x1337`

## Level 2

Simple register move like previously and a simple `add rdi, rax` (assuming you put the value in `rax`)

## Level 3

Register multiplication (`imul`) and register addition (`add`)

## Level 4

`div` being unsigned division requires dividend in `rax` before starting. So `mov` accordingly.

## Level 5

`%` operation: had to extract `div` remainder from `rdx`

## Level 6

Typical backward compatibility. Note that you need to move 8-bits into 8-bit space and 16-bits into 16-bit space

## Level 7

Basic left shift and right shift. Note that unit of shifts must be in *bits*, so to shift a byte, shift by 8 bits.

## Level 8

Bitwise AND/OR/XOR operations. To move an element from one register to another, xor out the desination register and then xor out the thing

## Level 9

Bitwise AND/OR/XOR

```s
Solution redacted
```

## Level 10

Proper indirect addressing

```s
Solution redacted
```

## Level 11

**Different word sizes**: byte, word, double-word, quad-word

```s
Solution redacted
```

## Level 12


```s
Solution redacted
```

## Level 13

Typical offset measurements

```s
Solution redacted
```

## Level 14

Sample `push` and `pop` operations

```s
Solution redacted
```

## Level 15

A prime on LIFO behaviour of stack.

```s
Solution redacted
```

## Level 16

A typical stack memory access through `[rsp]` and byte offsets.

```s
Solution redacted
```

## Level 17

Relative and absolute jump

## Level 18

Leveled if-else ladder

```s
Solution redacted
```

## Level 19

Conceptual introduction to a jump/lookup/switch-case table

```s
Solution redacted
```

## Level 20

A simple `for` loop.

```s
Solution redacted
```

## Level 21

A simple `while` loop to count the number of consequetive non-zero bytes in memory should `rdi` be non null

```s
Solution redacted
```

## Level 22

Make sure to save and restore `rdi` surrounding the `call`. Also make sure to operate in bytes. Finally, the idea of the challenge is to write everything as a function, so you need the `ret` at the end (else it will keep showing **UNMAPPED MEMORY ACCESS ERROR**, which is your function not restoring the `rip` at the end of the code)

```s
Solution redacted
```

## Level 23

A few things to keep in mind:

    - Frequency of the bytes is 2 bytes long. So you need to multiply by 2 in order to calculate the offset
    
    - saving and restoring the rbp in the function
    
    - Looks like the initial version of counting sort to me. 

```s
Solution redacted
```
