# Embryoasm

## General pointers

To run a challenge:

1. Write assemly in a `.s` file

2. Compile with `gcc -nostdlib -static level1.s -o level1-elf`

3. Dump `.text` bytes with `objcopy --dump-section .text=level1 level1-elf`

4. Run `/challenge/embryoasm_level1 < level1`. If everything went right, there would be a flag displayed. Submit the flag and get points :)


## Assembly header

I like this header. So I keep it everywhere

```s
.global _start

_start:
.intel_syntax noprefix
```

## Generic notes

- [Instruction manual](https://www.felixcloutier.com/x86/)

- `imul` is signed multiplication and will allow you to choose source and destination registers. `mul` is unsigned and is limited to `rax` on x64 (and `eax` on x86)

- `div`  is unsigned divide wherein `rax` is divided by some register placing the quotient in `rax` and remainder in `rdx`

- **Backward compatibility**: Design decisions were made to not allow backward compatability for any register other than `rax`, `eax`, `ax`, `al`/`ah` (why would you need lower bits of stack pointer, base pointer etc)

- Immediate operand makes a `mov` turn into `movabs`: `movabs  rax, 0xdeadbeef00001337`

- `mov     qword ptr [rdi], rax` means a `qword` is being moved to `ptr [rdi]` (or to the memory being pointed to by `rdi`)

- All offsets are in `bytes`.

## Level 1

A simple register move: `mov rdi, 0x1337`

## Level 2

Simple register move like previously and a simple `add rdi, rax` (assuming you put the value in `rax`)

## Level 3

Register multiplication (`imul`) and register addition (`add`)

## Level 4

`div` being unsigned division requires dividend in `rax` before starting. So `mov` accordingly.

## Level 5

`%` operation: had to extract `div` remainder from `rdx`

## Level 6

Typical backward compatibility. Note that you need to move 8-bits into 8-bit space and 16-bits into 16-bit space

## Level 7

Basic left shift and right shift. Note that unit of shifts must be in *bits*, so to shift a byte, shift by 8 bits.

## Level 8

Bitwise AND/OR/XOR operations. To move an element from one register to another, xor out the desination register and then xor out the thing

## Level 9

Bitwise AND/OR/XOR

```s
and rdi, 0x1
xor rax, rax
xor rax, rdi
xor rax, 0x1
```

## Level 10

Proper indirect addressing

```s
mov rax, [0x404000]
mov rdi, [0x404000]
add rdi, 0x1337
mov rbx, 0x404000
mov [rbx], rdi
```

## Level 11

**Different word sizes**: byte, word, double-word, quad-word

```s
mov al, [0x404000]      ; move byte
mov bx, [0x404000]      ; move word
mov ecx, [0x404000]     ; move double word
mov rdx, [0x404000]     ; move quad-word
```

## Level 12


```s
0x400000:       movabs  rax, 0xdeadbeef00001337
0x40000a:       mov     qword ptr [rdi], rax
0x40000d:       movabs  rax, 0xc0ffee0000
0x400017:       mov     qword ptr [rsi], rax
```

## Level 13

Typical offset measurements

```s
0x400000:       mov     r8, qword ptr [rdi]
0x400003:       mov     r9, qword ptr [rdi + 8]
0x400007:       add     r8, r9
0x40000a:       mov     qword ptr [rsi], r8
```

## Level 14

Sample `push` and `pop` operations

```s
0x400000:       pop     rdx
0x400001:       sub     rdx, rdi
0x400004:       push    rdx
```

## Level 15

A prime on LIFO behaviour of stack.

```s
0x400000:       push    rdi
0x400001:       push    rsi
0x400002:       pop     rdi
0x400003:       pop     rsi
```
