# Embryoasm

## General pointers

To run a challenge:

1. Write assemly in a `.s` file

2. Compile with `gcc -nostdlib -static level1.s -o level1-elf`

3. Dump `.text` bytes with `objcopy --dump-section .text=level1 level1-elf`

4. Run `/challenge/embryoasm_level1 < level1`. If everything went right, there would be a flag displayed. Submit the flag and get points :)


## Assembly header

I like this header. So I keep it everywhere

```s
.global _start

_start:
.intel_syntax noprefix
```

## Generic notes

- [Instruction manual](https://www.felixcloutier.com/x86/)

- `imul` is signed multiplication and will allow you to choose source and destination registers. `mul` is unsigned and is limited to `rax` on x64 (and `eax` on x86)

- `div`  is unsigned divide wherein `rax` is divided by some register placing the quotient in `rax` and remainder in `rdx`. Division proceeds by taking the 128 bit register pair `rdx:rax` and divides it by the input register. This means it requires to zero out `rdx` before carrying out the operation/

- **Backward compatibility**: Design decisions were made to not allow backward compatability for any register other than `rax`, `eax`, `ax`, `al`/`ah` (why would you need lower bits of stack pointer, base pointer etc)

- Immediate operand makes a `mov` turn into `movabs`: `movabs  rax, 0xdeadbeef00001337`

- `mov     qword ptr [rdi], rax` means a `qword` is being moved to `ptr [rdi]` (or to the memory being pointed to by `rdi`)

- All offsets are in `bytes`.

- `jmp 0x400028` translates to opcode `e9` which is a relative near jump.

- `cmp` won't work with both dereferencing and immediate operands. Use registers in order to use dereferencing.

- None of the conditional jump instructions can take anything other than relative 8 bits, 16 bits, and 32 bits addresses.

- Be wary of hidden parameters. For example, `mul` wants a null `rdx` etc. Thereby, if you use `rdx` in computation, it might keep resetting to 0.

- x86 calling conventions keep arguments in registers. Like first argument is in `rdi` and so on. Return value is in `rax`.

## Level 1

A simple register move: `mov rdi, 0x1337`

## Level 2

Simple register move like previously and a simple `add rdi, rax` (assuming you put the value in `rax`)

## Level 3

Register multiplication (`imul`) and register addition (`add`)

## Level 4

`div` being unsigned division requires dividend in `rax` before starting. So `mov` accordingly.

## Level 5

`%` operation: had to extract `div` remainder from `rdx`

## Level 6

Typical backward compatibility. Note that you need to move 8-bits into 8-bit space and 16-bits into 16-bit space

## Level 7

Basic left shift and right shift. Note that unit of shifts must be in *bits*, so to shift a byte, shift by 8 bits.

## Level 8

Bitwise AND/OR/XOR operations. To move an element from one register to another, xor out the desination register and then xor out the thing

## Level 9

Bitwise AND/OR/XOR

```s
and rdi, 0x1
xor rax, rax
xor rax, rdi
xor rax, 0x1
```

## Level 10

Proper indirect addressing

```s
mov rax, [0x404000]
mov rdi, [0x404000]
add rdi, 0x1337
mov rbx, 0x404000
mov [rbx], rdi
```

## Level 11

**Different word sizes**: byte, word, double-word, quad-word

```s
mov al, [0x404000]      ; move byte
mov bx, [0x404000]      ; move word
mov ecx, [0x404000]     ; move double word
mov rdx, [0x404000]     ; move quad-word
```

## Level 12


```s
0x400000:       movabs  rax, 0xdeadbeef00001337
0x40000a:       mov     qword ptr [rdi], rax
0x40000d:       movabs  rax, 0xc0ffee0000
0x400017:       mov     qword ptr [rsi], rax
```

## Level 13

Typical offset measurements

```s
0x400000:       mov     r8, qword ptr [rdi]
0x400003:       mov     r9, qword ptr [rdi + 8]
0x400007:       add     r8, r9
0x40000a:       mov     qword ptr [rsi], r8
```

## Level 14

Sample `push` and `pop` operations

```s
0x400000:       pop     rdx
0x400001:       sub     rdx, rdi
0x400004:       push    rdx
```

## Level 15

A prime on LIFO behaviour of stack.

```s
0x400000:       push    rdi
0x400001:       push    rsi
0x400002:       pop     rdi
0x400003:       pop     rsi
```

## Level 16

A typical stack memory access through `[rsp]` and byte offsets.

```s
0x400000:       mov     r8, qword ptr [rsp]
0x400004:       mov     r9, qword ptr [rsp + 8]
0x400009:       mov     r10, qword ptr [rsp + 0x10]
0x40000e:       mov     r11, qword ptr [rsp + 0x18]
0x400013:       xor     rax, rax
0x400016:       add     rax, r8
0x400019:       add     rax, r9
0x40001c:       add     rax, r10
0x40001f:       add     rax, r11
0x400022:       xor     rdx, rdx
0x400025:       mov     rbx, 4
0x40002c:       div     rbx
0x40002f:       push    rax
```

## Level 17

Relative and absolute jump

## Level 18

Leveled if-else ladder

```s
0x400000:       mov     esi, 0x7f454c46
0x400005:       cmp     dword ptr [edi], esi
0x400008:       jne     0x40001a
0x40000a:       xor     eax, eax
0x40000c:       mov     eax, dword ptr [edi + 4]
0x400010:       add     eax, dword ptr [edi + 8]
0x400014:       add     eax, dword ptr [edi + 0xc]
0x400018:       jmp     0x400044
0x40001a:       mov     esi, 0x5a4d
0x40001f:       cmp     dword ptr [edi], esi
0x400022:       jne     0x400034
0x400024:       xor     eax, eax
0x400026:       mov     eax, dword ptr [edi + 4]
0x40002a:       sub     eax, dword ptr [edi + 8]
0x40002e:       sub     eax, dword ptr [edi + 0xc]
0x400032:       jmp     0x400044
0x400034:       xor     eax, eax
0x400036:       mov     eax, dword ptr [edi + 4]
0x40003a:       imul    eax, dword ptr [edi + 8]
0x40003f:       imul    eax, dword ptr [edi + 0xc]
```

## Level 19

Conceptual introduction to a jump/lookup/switch-case table

```s
0x400000:       cmp     rdi, 3
0x400004:       jg      0x400019
0x400006:       xor     rdx, rdx
0x400009:       mov     rax, rdi
0x40000c:       mov     r8, 8
0x400013:       mul     r8
0x400016:       jmp     qword ptr [rsi + rax]
0x400019:       mov     r9, qword ptr [rsi + 0x20]
0x40001d:       jmp     r9
```

## Level 20

A simple `for` loop.

```s
0x400000:       xor     rax, rax
0x400003:       xor     rbx, rbx
0x400006:       mov     r14, 0
0x40000d:       mov     rdx, 0
0x400014:       cmp     r14, rsi
0x400017:       je      0x40002f
0x400019:       mov     rax, 4
0x400020:       mul     r14
0x400023:       mov     eax, dword ptr [rdi + rax]
0x400026:       add     rbx, rax
0x400029:       add     r14, 1
0x40002d:       jmp     0x400014
0x40002f:       xor     rdx, rdx
0x400032:       mov     rax, rbx
0x400035:       div     rsi
```

## Level 21

A simple `while` loop to count the number of consequetive non-zero bytes in memory should `rdi` be non null

```s
0x400000:       mov     rax, 0
0x400007:       cmp     rdi, 0
0x40000b:       je      0x400032
0x40000d:       mov     r8, 0
0x400014:       mov     r9, 0
0x40001b:       mov     rax, r8
0x40001e:       mov     sil, byte ptr [rdi + r9]
0x400022:       cmp     sil, 0
0x400026:       je      0x400032
0x400028:       add     r8, 1
0x40002c:       add     r9, 1
0x400030:       jmp     0x40001b
```

## Level 22

Make sure to save and restore `rdi` surrounding the `call`. Also make sure to operate in bytes. Finally, the idea of the challenge is to write everything as a function, so you need the `ret` at the end (else it will keep showing **UNMAPPED MEMORY ACCESS ERROR**, which is your function not restoring the `rip` at the end of the code)

```s
0x400000:       xor     rax, rax
0x400003:       cmp     rdi, 0
0x400007:       je      0x400047
0x400009:       mov     r11, 0x403000
0x400010:       mov     r9, 0
0x400017:       mov     r10, 0
0x40001e:       mov     sil, byte ptr [rdi + r9]
0x400022:       mov     rax, r10
0x400025:       cmp     sil, 0
0x400029:       je      0x400047
0x40002b:       cmp     sil, 0x5a
0x40002f:       jg      0x400041
0x400031:       push    rdi
0x400032:       mov     rdi, rsi
0x400035:       call    r11
0x400038:       pop     rdi
0x400039:       mov     byte ptr [rdi + r9], al
0x40003d:       add     r10, 1
0x400041:       add     r9, 1
0x400045:       jmp     0x40001e
0x400047:       ret
```

## Level 23

A few things to keep in mind:

    - Frequency of the bytes is 2 bytes long. So you need to multiply by 2 in order to calculate the offset
    
    - saving and restoring the rbp in the function
    
    - Looks like the initial version of counting sort to me. 

```s
0x400000:       mov     rbp, rsp
0x400003:       mov     r14, 2
0x40000a:       imul    r14, r14, 0xffff
0x400011:       sub     rsp, r14
0x400014:       mov     r8, 0
0x40001b:       mov     r9, 0
0x400022:       cmp     r9, rsi
0x400025:       je      0x400045
0x400027:       mov     cl, byte ptr [rdi + r9]
0x40002b:       mov     r10, rsp
0x40002e:       imul    r12, rcx, 2
0x400032:       sub     r10, r12
0x400035:       mov     r11, 1
0x40003c:       add     qword ptr [r10], r11
0x40003f:       add     r9, 1
0x400043:       jmp     0x400022
0x400045:       mov     rdx, 0
0x40004c:       mov     rax, 0
0x400053:       mov     rcx, 0
0x40005a:       cmp     cx, 0xff
0x40005f:       je      0x400084
0x400061:       mov     r14, rcx
0x400064:       imul    r14, r14, 2
0x400068:       mov     r12, rsp
0x40006b:       sub     r12, r14
0x40006e:       mov     si, word ptr [r12]
0x400073:       cmp     rdx, rsi
0x400076:       jge     0x40007e
0x400078:       mov     dx, si
0x40007b:       mov     rax, rcx
0x40007e:       add     rcx, 1
0x400082:       jmp     0x40005a
0x400084:       mov     rsp, rbp
0x400087:       ret
```
