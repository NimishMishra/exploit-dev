#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int BUFFER_LENGTH = 4096;
int NUMFILES = 4;
char filenames[][20] = {
    "javaprog.java",
    "tc1.java",
    "tc2.java",
    "tc3.java"
    };
char fileBUFFER[4096];

int NUM_KEYWORDS = 48;
char keywords[][20] = {
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "if",
    "implements",
    "import",
    "instance of",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "strictfp",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "try",
    "void",
    "volatile",
    "while"    
};

typedef enum {
    token_whitespace,

    // arithmetic operators
    token_multiply,
    token_add,
    token_divide,
    token_mod,
    token_subtract,
    token_assign,

    // relational and logical operators
    token_not,
    token_negate,
    token_and,
    token_or,
    token_less,
    token_less_equal,
    token_greater,
    token_greater_equal,
    token_equal,
    token_not_equal,


    // separators
    token_left_paranthesis,
    token_left_curly_paranthesis,
    token_left_square_paranthesis,
    token_right_paranthesis,
    token_right_curly_paranthesis,
    token_right_square_paranthesis,
    token_semicolon,
    token_comma,
    

    // others
    token_number,
    token_keyword,
    token_identifier, // any identifier
    token_string,

    token_single_line_comment,
    token_multi_line_comment
} Type;

typedef struct {
    int shouldPrint;
    Type type;
    int row;
    int col;
    int startIndex;
    int endIndex;   
} Token;


int row = 1;
int col = 0;
int BUFFER_INDEX = 0;

void red_color () {
  printf("\033[1;31m");
}

void green_color () {
  printf("\033[1;32m");
}

void blue_color(){
    printf("\033[1;34m");
}

void magenta_color(){
    printf("\033[1;35m");
}

void yellow_color() {
  printf("\033[1;33m");
}

void cyan_color() {
  printf("\033[1;36m");
}

void reset_color () {
  printf("\033[0m");
}


Token identifier_or_integer_or_keyword(char ch){
    int startIndex = BUFFER_INDEX;
    int endIndex = startIndex + 1;
    char nextChar;

    if(ch >= '0' && ch <= '9'){
        // it is a number
        col++;
        while(1){
            nextChar = fileBUFFER[endIndex];
            if((nextChar >= '0' && nextChar <= '9') ||
                nextChar == '.' ||
                nextChar == 'e' ||
                nextChar == 'E' ||
                nextChar == '+' ||
                nextChar == '-'
            ){
                if(nextChar == '+' || nextChar == '-')
                    {
                        if(fileBUFFER[endIndex - 1] == 'E' || fileBUFFER[endIndex - 1] == 'e'){
                            ;
                        }
                        else{
                            endIndex = endIndex - 1;
                            break;
                        }
                    }
            }

            else{
                endIndex = endIndex - 1;
                break;
            }
            endIndex ++;
        }
        BUFFER_INDEX = endIndex + 1;
        //printf("%d %d %d \n", startIndex, endIndex, BUFFER_INDEX);
        return (Token){1, token_number, row, col, startIndex, endIndex};
    }

    else if((ch >= 'A' && ch <= 'Z') || (ch >= 'a' || ch <= 'z')){
        // it is a string
        // printf("%d %d %d \n", startIndex, endIndex, BUFFER_INDEX);
        while(1){
            col++;
            if(fileBUFFER[endIndex] == EOF){
                printf("%d ", endIndex);
                endIndex = endIndex - 1;
                break;
            }


            nextChar = fileBUFFER[endIndex];
            if(
                (nextChar >= 'A' && nextChar <= 'Z') || 
                (nextChar >= 'a' && nextChar <= 'z') || 
                nextChar == '_' || 
                nextChar == '$' || 
                (nextChar >= '0' && nextChar <= '9')
            ){
                ;
            }

            else{
                endIndex = endIndex - 1;
                break;
            }

            endIndex++;         
        }

        BUFFER_INDEX = endIndex + 1;

        char keyword[20]; int index = 0;
        int buffer_index = startIndex;
        while(buffer_index <= endIndex){
            keyword[index] = fileBUFFER[buffer_index];
            index++;
            buffer_index ++;
        }
        keyword[index] = '\0';
        for(int i = 0; i < NUM_KEYWORDS; i++){

            if(!(strcmp(keyword, keywords[i])))
                return (Token){1, token_keyword, row, col, startIndex, endIndex};        
        }

        return (Token){1, token_identifier, row, col, startIndex, endIndex};
    }

    return (Token){1, token_number, row, col, startIndex, endIndex};

}

Token check_relational_logical_operator(Type token){
    char next_char = fileBUFFER[BUFFER_INDEX + 1];
    int end_Index = BUFFER_INDEX;
    if(token == token_not){
        if(next_char == '='){
            end_Index++;
            BUFFER_INDEX++;
            return (Token){1, token_not_equal, row, col, BUFFER_INDEX - 1, end_Index};
        }
        else{
            return (Token){1, token_not, row, col, BUFFER_INDEX, BUFFER_INDEX};
        }
    }

    if(token == token_greater){
        if(next_char == '='){
            end_Index++;
            BUFFER_INDEX++;
            return (Token){1, token_greater_equal, row, col, BUFFER_INDEX - 1, end_Index};
        }
        else{
            return (Token){1, token_greater, row, col, BUFFER_INDEX, BUFFER_INDEX};
        }
    }

    if(token == token_less){
        if(next_char == '='){
            end_Index++;
            BUFFER_INDEX++;
            return (Token){1, token_less_equal, row, col, BUFFER_INDEX - 1, end_Index};
        }
        else{
            return (Token){1, token_less, row, col, BUFFER_INDEX, BUFFER_INDEX};
        }
    }

    if(token == token_and){
        if(next_char == '&'){
            int start = BUFFER_INDEX;
            int end = BUFFER_INDEX + 1;
            BUFFER_INDEX ++;
            return (Token){1, token_and, row, col, start, end};
        }
        return (Token){1, token_and, row, col, BUFFER_INDEX, BUFFER_INDEX};
    }

    if(token == token_or){
        if(next_char == '|'){
            int start = BUFFER_INDEX;
            int end = BUFFER_INDEX + 1;
            BUFFER_INDEX ++;
            return (Token){1, token_and, row, col, start, end};
        }
        return (Token){1, token_and, row, col, BUFFER_INDEX, BUFFER_INDEX};
    }
    return (Token){1, token_not_equal, row, col, BUFFER_INDEX - 1, end_Index};
}

Token check_divide_comments(Type token){


    if(fileBUFFER[BUFFER_INDEX + 1] == '*' || fileBUFFER[BUFFER_INDEX + 1] == '/'){
        // comment encountered
        int startIndex = BUFFER_INDEX;
        int endIndex = BUFFER_INDEX;

        if(fileBUFFER[startIndex + 1] == '/'){
            // single line comment

            while(fileBUFFER[endIndex] != '\n'){
                endIndex++;
            }
            BUFFER_INDEX = endIndex;
            return (Token){1, token_single_line_comment, row, col, startIndex, endIndex - 1};
        }

        else{
            endIndex += 2;
            // multiline comment
            while(fileBUFFER[endIndex] != '*' &&
            fileBUFFER[endIndex+1] != '/'){
                endIndex++;
            }
            BUFFER_INDEX = endIndex+1;
            return (Token){1, token_multi_line_comment, row, col, startIndex, endIndex - 1};
        }
    }

        return (Token){1, token_divide, row, col, BUFFER_INDEX, BUFFER_INDEX};    
}

Token check_string_literal(Type token){
    int startIndex = BUFFER_INDEX;
    int endIndex = BUFFER_INDEX + 1;

    while(fileBUFFER[endIndex] != '"'){
        endIndex++;
    }
    BUFFER_INDEX = endIndex;
    return (Token){1, token_string, row, col, startIndex, endIndex};
}

Token tokenize(char ch){
    col++;
    if(ch == ' ' || ch == '\t' || ch == '\n'){
        if(ch == '\n'){
            ++row;
            col = 0;
        }
        return (Token){0, token_whitespace};
    }
    switch(ch){
        case '{': return (Token){1, token_left_curly_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '}': return (Token){1, token_right_curly_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '(': return (Token){1, token_left_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case ')': return (Token){1, token_right_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '[': return (Token){1, token_left_square_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case ']': return (Token){1, token_right_square_paranthesis, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '=': return (Token){1, token_assign, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '*': return (Token){1, token_multiply, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '/': return check_divide_comments(token_divide);
        case '+': return (Token){1, token_add, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '%': return (Token){1, token_mod, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '-': return (Token){1, token_subtract, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case ';': return (Token){1, token_semicolon, row, col, BUFFER_INDEX, BUFFER_INDEX};
        case '!': return check_relational_logical_operator(token_not);
        case '>': return check_relational_logical_operator(token_greater);
        case '<': return check_relational_logical_operator(token_less);
        case '&': return check_relational_logical_operator(token_and);
        case '|': return check_relational_logical_operator(token_or);
        case '"': return check_string_literal(token_string);
        default: return identifier_or_integer_or_keyword(ch);
    }


}

void analyse(char* filename){
    BUFFER_INDEX = -1;
    Token token;
    col = 0;
    do{
        BUFFER_INDEX++;
        
        token = tokenize(fileBUFFER[BUFFER_INDEX]);
        if(token.type == token_number || token.type  == token_identifier){
            for(int i = token.startIndex; i <= token.endIndex; i++){
                if(fileBUFFER[i] == '\t' || fileBUFFER[i] ==  '\n')
                    continue;
                printf("%c", fileBUFFER[i]);
            }
            printf("\t => %s at row %d and col %d\n", (token.type == token_number)? "Number":"Identifier", row, col);
        }

        else if(token.type == token_keyword){
            red_color();
            for(int i = token.startIndex; i <= token.endIndex; i++){
                if(fileBUFFER[i] == '\t' || fileBUFFER[i] ==  '\n')
                    continue;
                printf("%c", fileBUFFER[i]);
            }
            printf("\t => %s at row %d and col %d\n", "Keyword", row, col);
            reset_color();
        }

        else if(
            token.type == token_left_paranthesis ||
            token.type == token_left_curly_paranthesis ||
            token.type == token_left_square_paranthesis ||
            token.type == token_right_paranthesis ||
            token.type == token_right_curly_paranthesis ||
            token.type == token_right_square_paranthesis || 
            token.type == token_semicolon){
            green_color();
            printf("%c \t => %s is at row %d and col %d\n", fileBUFFER[BUFFER_INDEX], "Separator", row, col);
            reset_color();
        }

        else if(
            token.type == token_assign
        ){
            blue_color();
            printf("%c \t => %s is at row %d and col %d\n", fileBUFFER[BUFFER_INDEX], "Assignment Operator", row, col);
            reset_color();
        }

        else if(
            token.type == token_multiply ||
            token.type == token_add ||
            token.type == token_divide ||
            token.type == token_mod ||
            token.type == token_subtract
        ){
            blue_color();
            printf("%c \t => %s is at row %d and col %d\n", fileBUFFER[BUFFER_INDEX], "Binary arithmetic operator", row, col);
            reset_color();
        }

        else if(
            token.type == token_not ||
            token.type == token_not_equal ||
            token.type == token_less ||
            token.type == token_less_equal ||
            token.type == token_greater ||
            token.type == token_greater_equal ||
            token.type == token_and || 
            token.type == token_or
        ){
            magenta_color();
            for(int i = token.startIndex; i <= token.endIndex; i++){
                printf("%c", fileBUFFER[i]);
            }
            printf("\t => %s is at row %d and col %d\n", "Relational or logical operator", row, col);
            reset_color();
        }

        else if(token.type == token_single_line_comment ||
        token.type == token_multi_line_comment){
            yellow_color();
            for(int i = token.startIndex; i <= token.endIndex; i++){
                printf("%c", fileBUFFER[i]);
            }
            printf("\t => %s is at row %d and col %d\n", (token.type == token_single_line_comment)?"Single line Comment" : "Multi line comment", row, col);
            reset_color();
        }

        else if(token.type == token_string){
            cyan_color();
            for(int i = token.startIndex; i <= token.endIndex; i++){
                printf("%c", fileBUFFER[i]);
            }
            printf("\t => %s is at row %d and col %d\n", "String literal", row, col);
            reset_color();
        }

        if(fileBUFFER[BUFFER_INDEX] == ';'){
            green_color();
            printf("%c \t => %s is at row %d and col %d\n", fileBUFFER[BUFFER_INDEX], "Semicolon separator", row, col);
            reset_color();
        }        

    }while(fileBUFFER[BUFFER_INDEX + 1] != EOF);
    
    printf("\n");

    printf("--------------------------------------\n");
}


void readFile(char* fileName){
    // clear file buffer
    for(int i = 0; i < BUFFER_LENGTH; i++){
        fileBUFFER[i] = '\0';

    }

    printf("\n\n\n");
    char filePath[30] = "./test_cases/";
    strcat(filePath, fileName);
    FILE *fp = fopen(filePath, "r");
    if(fp == NULL){
        if(!strcmp(fileName, "javaprog.java")){
            printf("javaprog.java NOT found in ./test_cases/\n Please provide it for custom test case.\nContinuing with other test cases\n");
        }
        else{
            printf("Test case file %s missing, have you removed it?\n", fileName);
        }
        return;
    }

    printf("Lexical analysis of %s \n\n", fileName);

    char ch;
    int index = 0;
    while((ch = fgetc(fp)) != EOF || index < BUFFER_LENGTH){
        fileBUFFER[index] = ch;
        //printf("%c", fileBUFFER[index]);
        index ++;
    }
    fileBUFFER[index] = EOF;
    analyse(fileName);
    fclose(fp);
}

void print_color_codes(){
    printf("COLOR CODES: \n");
    printf("Number/Identifier\t");
    red_color();
    printf("Keyword\t\t");
    reset_color();
    green_color();
    printf("Separator\t");
    reset_color();
    blue_color();
    printf("Assignment/arithmetic Operator\t");
    reset_color();
    magenta_color();
    printf("Relational/Logical operator\t");
    reset_color();
    yellow_color();
    printf("Comment\t");
    reset_color();

    printf("\n");
}

int main(){
    print_color_codes();
    for(int i = 0; i < NUMFILES; i++){
        row = 1;
        col = 0;
        BUFFER_INDEX = 0;
        readFile(filenames[i]);
    }

    printf("\n");
    print_color_codes();
}