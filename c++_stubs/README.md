# C++ Stubs

A set of C++ stubs

## General pointers

- All C++ names are defined in a separate namespace (`std`) and the namespace must be used in a given program before we can use the names

- #include is a `preprocessor directive` which is used to include header files in a C++ source. `<>` means standard headers and the search for such a thing begins at the path defined in the environment. `#include "..."` implies the search begins from the directory the source is currently located.

- Header files may themselves have other includes within them, so we include a `#ifndef` directive that checks if the definition has been made somewhere else before. This is the conditional directive and evaluates to true or false.

```c
#ifndef FILENAME_H
#define FILENAME_H


#endif
```

A sister conditional directive is `ifdef`, that can compile a given code in different ways based upon what is defined.

```c
#ifdef DEBUG
....
#endif

- Some other preprocessing directives:

    - `__cplusplus` : automatically set when code is compiled using C++

    - `__STDC__`: automatically set when code is compiled using C

    - `__LINE__`: contains the current line number of the code being compiled

    - `__FILE__`: name of the current file being compiled

    - `__TIME__`: time of compilation

    - `__DATE__`: date of compilation

Compile with `g++ -DDEBUG .......`
```

- `assert()` from `#include <cassert>` is an implicit **true or exit** statement wherein either it is true or it sends an abort trap (a software abort interrupt).

- Namespaces are used by library vendors to prevent namespace pollution. Consider something like two names `assert()`: one from standard C++ installation and the other from a user. These will collide. So the difference is maintained through `std::assert()` and `user_defined_namespace::assert()`.

- File: `ifstream infile("....")` and `ofstream outfile(...);`

- Dynamic object allocation needs to be taken care of by the programmar, since for reasons very well explained in a compiler course, C++ is pooly suited to automated garbage collector.

- Private members of the class can only be accessed by only the member functions and the friends of the class.

- `const` is a very handy tool to have. The logic that say you have a constant value to place at some portion of the code. You could do `int constant_value = val;` and place it. But now this shall become a valid lvalue and can be accidently changed in the course of execution, and therefore `const` was introduced to prevent these unintentional/intentional changes to specific lvalues. Moreover, pointers can arbitrarily change anything, and thus compiler doesn't allow pointers to constant values. However, a `const int*` can be assigned. But this pointer is itself not constant. This, rather than meaning it's a constant pointer, rather means it's a pointer to a constant object.

- Constant pointers are indeed possible. You could do `int* const pointer = &value;`. Now you can't assign this to any another address.

- Constant pointer to constant object is captured by combining the two things above:

	- `const int* pointer`: non-constant pointer to constant object
	
	- `int* const pointer`: constant pointer to non-constant object

So do a simple `const int* const pointer;` to get a const (2nd `const`) pointer to a const(1st `const`) object

- References are like and unlike pointers in every sense. It is imperative to initialize a reference `int& ref = val;`. Then simply using `ref` anywhere uses the value of val at that place. Since a reference is initialized, it can't be set to another object once initialized.

- **Constant references** are allowed for different data-types. Reason:

	- Imagine `double dval = 234.1; int& val = dval;`. This is expanded to `double dval=234.1; int temp=(int)dval; int&val = temp;`. Any changes to `val` shall reflect in `temp` and not in the original `dval`

	- Hence, heterogeneous data-types are not allowed for non-constant references. The only safe thing to do is **read**, which is why `const` references have been preferred. 

- Pointers vs references

	- References can't be null. Pointers can be.

		- `int* p = 0` or `int* p = NULL`  means the pointer points to nothing as of now. It is NULL

		- `const int& val = 0` does `int temp = 0; int& val = temp;`. So technically, it isn't NULL. Note `int& val = 0;` doesn't work because it won't allow a non-constant lvalue to rvalue of type int.

	- Assignments

		- Assigning pointers `p1 = p2` will make `p1` point to the address pointed to by `p2`

		- Assigning references `r1 = r1` will keep the references same, rather will change the actual value held by `r1` 

- `#include <complex>` gives elementary control over complex data types. I didn't go into depth into these things honestly.

### typedef

- Simply do a `typedef known_type user_defined_name` and you should be able to define `user_defined_name` as if you were declaring something with `known_type`

- `typedef char* ch` and `const ch cstr;` is `char* const cstr` (or constant pointer to non-constant object) rather than the evident `const char* cstr;` (or non-constant pointer to constant object). I do not yet understand this yet.

### volatile

- Variables that could be changed in ways the compiler can't detect (like depending on the hardware state). Compiler optimizations aren't really performed on such variables.

### pair

- A part of `utility` defined as `pair<int, string> dict(1, "name");`. Now `dict.first` = 1 and `dict.second` = "name"

### vectors

- It's what you would call a container type, basically containing a bunch of data.

- If you do a `vector<int> sample(10);`, then all `push_back` will rather add the new elements to the end of the vector, rather than over-write it.

- Value initialization in vector, `vector<int> sample(size, initial value);`

- Vectors are subscriptable as well

### OOP

- Implements information hiding (data abstraction), dynamic function binding, abstraction.

- Most types in C++ can be defined as simply as calling the constructors of that particular class. Like `int a(5); string b("aaa");`

### Inline functions

- function calls are expensive. Inline functions allow you to let the function expand at the place of writing. It then becomes a direct memory access rather than a function call.

```c
for (int i = 0; i < array.size(); i++)

||
vv

for (int i = 0; i < array._size; i++)
```

### Exception handling

- `catch(...)` is tthe generic catch for all exceptions not caught by earlier catch statements.

### Inheritance

- C++ also has multiple inheritance (class is derived from two or more base classes) and virtual inheritance (single instance of a base class is shared among multiple derived classes).

### Namespace

- **namespace alias = original_namespace** where the latter is defined by **namespace original_namespace{}**

### Strings

- Declaring strings:
	
	- `string s = new string("aaa");`

	- `string b ("aaa");`

- `string.size()` to get the length of the string and cooly iterate over it.

- `string.empty()` to get if a given string is empty or not

- `st1 = st2`: first deletes the given storage of st1, then copies the contents of st2 over to st1

- String to char*: `char* s = string.c_str();`
