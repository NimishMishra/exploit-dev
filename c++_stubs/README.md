# C++ Stubs

A set of C++ stubs

## General pointers

- All C++ names are defined in a separate namespace (`std`) and the namespace must be used in a given program before we can use the names

- #include is a `preprocessor directive` which is used to include header files in a C++ source. `<>` means standard headers and the search for such a thing begins at the path defined in the environment. `#include "..."` implies the search begins from the directory the source is currently located.

- Header files may themselves have other includes within them, so we include a `#ifndef` directive that checks if the definition has been made somewhere else before. This is the conditional directive and evaluates to true or false.

```c
#ifndef FILENAME_H
#define FILENAME_H


#endif
```

A sister conditional directive is `ifdef`, that can compile a given code in different ways based upon what is defined.

```c
#ifdef DEBUG
....
#endif

- Some other preprocessing directives:

    - `__cplusplus` : automatically set when code is compiled using C++

    - `__STDC__`: automatically set when code is compiled using C

    - `__LINE__`: contains the current line number of the code being compiled

    - `__FILE__`: name of the current file being compiled

    - `__TIME__`: time of compilation

    - `__DATE__`: date of compilation

Compile with `g++ -DDEBUG .......`
```

- `assert()` from `#include <cassert>` is an implicit **true or exit** statement wherein either it is true or it sends an abort trap (a software abort interrupt).

- Namespaces are used by library vendors to prevent namespace pollution. Consider something like two names `assert()`: one from standard C++ installation and the other from a user. These will collide. So the difference is maintained through `std::assert()` and `user_defined_namespace::assert()`.

- File: `ifstream infile("....")` and `ofstream outfile(...);`

- Dynamic object allocation needs to be taken care of by the programmar, since for reasons very well explained in a compiler course, C++ is pooly suited to automated garbage collector.

- Private members of the class can only be accessed by only the member functions and the friends of the class.

- `const` is a very handy tool to have. The logic that say you have a constant value to place at some portion of the code. You could do `int constant_value = val;` and place it. But now this shall become a valid lvalue and can be accidently changed in the course of execution, and therefore `const` was introduced to prevent these unintentional/intentional changes to specific lvalues. Moreover, pointers can arbitrarily change anything, and thus compiler doesn't allow pointers to constant values. However, a `const int*` can be assigned. But this pointer is itself not constant. This, rather than meaning it's a constant pointer, rather means it's a pointer to a constant object.

- Constant pointers are indeed possible. You could do `int* const pointer = &value;`. Now you can't assign this to any another address.

- Constant pointer to constant object is captured by combining the two things above:

	- `const int* pointer`: non-constant pointer to constant object
	
	- `int* const pointer`: constant pointer to non-constant object

So do a simple `const int* const pointer;` to get a const (2nd `const`) pointer to a const(1st `const`) object

- References are like and unlike pointers in every sense. It is imperative to initialize a reference `int& ref = val;`. Then simply using `ref` anywhere uses the value of val at that place. Since a reference is initialized, it can't be set to another object once initialized. References are however allowed as function parameters, and this is because you specifically initialize it when the function gets called.

- **Constant references** are allowed for different data-types. Reason:

	- Imagine `double dval = 234.1; int& val = dval;`. This is expanded to `double dval=234.1; int temp=(int)dval; int&val = temp;`. Any changes to `val` shall reflect in `temp` and not in the original `dval`

	- Hence, heterogeneous data-types are not allowed for non-constant references. The only safe thing to do is **read**, which is why `const` references have been preferred. 

- Pointers vs references

	- References can't be null. Pointers can be.

		- `int* p = 0` or `int* p = NULL`  means the pointer points to nothing as of now. It is NULL

		- `const int& val = 0` does `int temp = 0; int& val = temp;`. So technically, it isn't NULL. Note `int& val = 0;` doesn't work because it won't allow a non-constant lvalue to rvalue of type int.

	- Assignments

		- Assigning pointers `p1 = p2` will make `p1` point to the address pointed to by `p2`

		- Assigning references `r1 = r1` will keep the references same, rather will change the actual value held by `r1` 

	- For instance, if you are building a function wherein you wish to dereference, it may be prudent to use references rather than pointers. Pointers need to be constantly checked if they are NULL. 

	- Reference parameters also aid a lot in operator overloading. Using pointer arguments, you would need to do things like `&a + &b`. Using references, overloading can succeed with just `a + b`.

- `#include <complex>` gives elementary control over complex data types. I didn't go into depth into these things honestly.

- `sizeof()` returns the size of the argument passed. Found in `cstddef`

- `(condition)? expr1, expr2, expr3 : expr4, expr5, expr6`

- inline functions are recompiled by the compiler and placed, in place, wherever the function is called. `inline` functions are recommendations to the compiler, not a necessary requirement it is supposed to meet. Compilers can choose to ignore this function if it feels the function is too complicated to be expanded inline at the point of function call.

- Container types comparison

	- vectors are stored sequentially in memory, so have really good random access. Linked lists are randomly placed in heap, so searching is linear in the number of elements.

	- insertion in a vector is inefficient because it needs shifting of all elements to the right

	- Container types are passed by values. Better to have pointers or references, as the case may be.

- Use of elipsis (...) in function prototype tells the compiler that (1) the number of arguments to be received is unknown and (2) the type of arguments is unknown. You could do a partial ellipsis: `int fun(int a, int b ...)`. So the first two are fine, the latter make no assumption on the number and type of arguments received.

- Scope vs lifetime

	- **Scope**: whence a name is visible

	- **Lifetime**: how long is the name valid (for instance, names restricted to function scope are invalid after the function exits/returns)

	- `extern int obj` does not cause storage allocation. It's only when you do a `int obj = 1` that storage comes and you have a scope.

- **Type-safe linkage**: number and types of arguments are encoded with function names to check if there is type mismatch of the same function declaration in different files.

- **Constant folding**: Compiler replaces the constant arithmetic in proper places.

- `auto_ptr` belongs to `#include <memory>` which allows programmers to automate the management of individual objects dynamically allocated through new expressions. This allows automatic deletion of dynamically allocated memory.

- `delete [] array_name` is used for automatic deletion of array object.

- `delete object;` is enough to deallocate a constant object.

- **Function pointers**: Say a function has to do computation that will be bounded at runtime. You could do a `switch-case` or you could do a function pointer.

```c++
void sort(vector<int>&, vector<int>&, void (*compare)()){

	compare(); // invoke the function simply
}

So a pointer looks like: DATATYPE (*FUNCTION_NAME)(...);

Assignment:

int (*func_pointer)(int, int) = min;
OR
sort(<vector1>, <vector2>, min);
sort(<vector1>, <vecto2>, max);
```

and use compare to do different things at runtime. 

- Arrays of pointers to function: `int (*func_pointer[10])(int)` makes an array of 10 pointers to functions of the type `int <name>(int);`

- For pointers to `extern "C"` functions, you would have `extern "C" int (*func_name)(...) = function;` where function is as in `extern "C" int function(...);`

- `extern` is implicitly assumed in function definitions; it allows you to have globally scoped functions.

- It is possible to have pointers to overloaded function, but the compiler is only sure about it after it has checked through the different function signatures.

- **Template argument deduction**: Compiler deduces the type of arguments of the template through the function call that was made.

### Linkage directives: extern "C"

- call a function written in C. The compiler now knows details must be handled quite differently from a C++ function.

- Compound linkage

```c++
extern "C"{
	#include <math.h>
	int printf(const char* ...); // a typical C function
}	
```

- linkage directive can't appear within a function body. 

- call a function written as C++ within C:

```c++
extern "C" {
	double func(){...}
}
```

- Overloading in linkage directive is not allowed. **Type-safe linkage** (linking function signatures in different files) is not done in case of `extern "C"` functions (implying you do not encode the type and number of arguments in the function name itself). So overloading isn't allowed (because in absence of encodings, the function names are same).

### Overload resolution order

- Identify the set of probable functions and have a look at their prototypes

- Select all functions that can be considered with the current call. For instance, both `int fun(int)` and `int fun(double)` are viable candidate functions for a call `fun(3);` 

- call the function that best matches the call (based on type conversions).

### typedef

- Simply do a `typedef known_type user_defined_name` and you should be able to define `user_defined_name` as if you were declaring something with `known_type`

- `typedef char* ch` and `const ch cstr;` is `char* const cstr` (or constant pointer to non-constant object) rather than the evident `const char* cstr;` (or non-constant pointer to constant object). I do not yet understand this yet.

### volatile

- Variables that could be changed in ways the compiler can't detect (like depending on the hardware state). Compiler optimizations aren't really performed on such variables.

### pair

- A part of `utility` defined as `pair<int, string> dict(1, "name");`. Now `dict.first` = 1 and `dict.second` = "name"

### stack

- another container type `#include <stack>`

	- `empty()`

	- `size()`
	
	- `pop()`

	- `top()`

	- `push(item)`

### queue

- yet another container type `#include <queue>`: very interesting to see the terminology not following standard queue and dequeue methods.

	- `empty()`

	- `size()`

	- `pop()`

	- `front()`

	- `back()`

	- `top()`

	- `push(item)`

### vectors

- It's what you would call a container type, basically containing a bunch of data of the same type. **Lists** are another example of container types.

- If you do a `vector<int> sample(10);`, then all `push_back` will rather add the new elements to the end of the vector, rather than over-write it.

- Value initialization in vector, `vector<int> sample(size, initial value);`

- Vectors are subscriptable as well

- Inserting at a particular position: `vector_name.insert(int pos, DATATYPE element);`

- You could define an iterator and do deletion on the same. For example, `vector<string>::iterator iter = find(list.begin(), list.end(), "value to find")`. Delete things like:

```c
if(iter != list.end())
	list.erase(iter);
```

- `swap()` allows you to swap things.

### OOP

- Implements information hiding (data abstraction), dynamic function binding, abstraction.

- Most types in C++ can be defined as simply as calling the constructors of that particular class. Like `int a(5); string b("aaa");`

### Inline functions

- function calls are expensive. Inline functions allow you to let the function expand at the place of writing. It then becomes a direct memory access rather than a function call.

```c
for (int i = 0; i < array.size(); i++)

||
vv

for (int i = 0; i < array._size; i++)
```

### Exception handling

- `catch(...)` is tthe generic catch for all exceptions not caught by earlier catch statements.

### Inheritance

- C++ also has multiple inheritance (class is derived from two or more base classes) and virtual inheritance (single instance of a base class is shared among multiple derived classes).

### Namespace

- **namespace alias = original_namespace** where the latter is defined by **namespace original_namespace{}**

### Strings

- Declaring strings:
	
	- `string s = new string("aaa");`

	- `string b ("aaa");`

- `string.size()` to get the length of the string and cooly iterate over it.

- `string.empty()` to get if a given string is empty or not

- `st1 = st2`: first deletes the given storage of st1, then copies the contents of st2 over to st1

- String to char*: `char* s = string.c_str();`
