# embryogdb

A refresher on general debugging techniques used.

## Level 1

Basics of running programs in gdb

## Level 2

A simple `info registers`

## Level 3

You can examine the contents of memory using the `x/<n><u><f> <address>` parameterized command. In this format `<u>` is
the unit size to display, `<f>` is the format to display it in, and `<n>` is the number of elements to display. Valid
unit sizes are `b` (1 byte), `h` (2 bytes), `w` (4 bytes), and `g` (8 bytes). Valid formats are `d` (decimal), `x`
(hexadecimal), `s` (string) and `i` (instruction). The address can be specified using a register name, symbol name, or
absolute address. Additionally, you can supply mathematical expressions when specifying the address.

## Level 4

You can examine the contents of memory yet again. `x/32x $rbp` will give a good idea of the base pointer and `x/64x $rsp` will give a good idea of the stack frame. Now disassemble the main function and see the argument to `rsi` of the `read` syscall. Depending on that and the memory profiling done, get the actual data.

## Level 5

Much like the previous level but now you have to manually decide where to set the breakpoint at. You could be better off with gdb scripting though.

## Level 6

Classic example of gdb scripting:

Now consider a similar, but slightly more advanced script using some commands you haven't yet seen:

```gdb
  start
  break *main+42
  commands
    silent
    set $local_variable = *(unsigned long long*)($rbp-0x32)
    printf "Current value: %llx\n", $local_variable
    continue
  end
  continue

```

In this case, the `silent` indicates that we want gdb to not report that we have hit a breakpoint, to make the output a
bit cleaner. Then we use the `set` command to define a variable within our gdb session, whose value is our local
variable. Finally, we output the current value using a formatted string.

To solve the level, simply tweek about the values of the gdb script. Everything should be fine.
