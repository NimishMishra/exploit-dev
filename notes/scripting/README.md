# Basic Scripting

`/etc/shells` has a list of available shells on your systems. Some may just be symlinks to another shells (like `zsh` is sometimes a symlink). `which bash` to get the path of the shell that needs to be used while scripting.

## General pointers

- Use `/dev/null` to basically write something you wish to be retained nowhere (retained >= not even writing to stdout file descriptor 2).

- In case you wish to `grep` a flag from a help menu, do `grep "\-p"`. Basically `-` is treated as its own thing

- Creating alias: `alias alias_name="command_to_run"`

- `type` somewhat works similarly to `which`, tells you which type of the command you are currently running

- `man` is already known. `apropos` basically searches the man pages for keywords. `info` is an extension of `man` but has less number of infomation pages.

- `$?` captures the return value of the last command

- Command groups:

    -   **( list )**: means environment is distinct from the current shell. For example, `unset x; (x=hello; echo $x); echo $x` Note the outer echo won't work, since x is local to the command group
    -   **{ list ; }**: means environment is borrowed from the current shell. Try the same `unset x; { x=hello; echo $x; }; echo $x`

    - `echo "$(</etc/os-release)"` will simply give the output back to echo.

    - `<(list)` and `>(list)` 

- Bash doesn't tolerate a space in assignment. That is treated like three different words.

- Similarly, positional arguments require a `${}` when position > 9.

- Parameter expansion. `$(default:-$HOME)` means if `default` is empty, then take `$HOME`. `$(default:=$HOME)` means if `default` is empty, then take `$HOME` and store it in `default` (the colon here treats emptiness as if it were unset. Try `echo $(default-$HOME)` and this does not treat empty string same as being unset.

- `${param:offset}` = extracts string from the offset to the end of the string

- `${param:offset:length}` = extracts string from the offset upto length of the string

- `${param#pattern}` = removes pattern from the left edge. For instance, `param=racecar`. Then `${param#*c}` means `ecar`. Likewise, removal from the right edge is done using `%`.

- List keys/indices in an array: `${!name[@]}`

- Print elements of the array `${name[@]}`

- List names matching a pattern: `${!pa@}`

- 

## sed basics

- `sed 's/<regex>/<regex>/g' <filename>`: s means find and replace, the two regex means which regex to find, and which regex to replace it with. `g` simply means find and replace every instance of the first regex. This won't however write to the file

- sed -i '...' <filename>: replaces things in-place (or write to the file)

## awk basics

It's more of a formatting tool. You have patterns, things to do for those patterns, some environment built-ins.

## less

- A simple `cat file | less`

- Search for any word: `/<word>` and keep pressing `n` to get to the other words.

- Go to the top: `g`. Go to the bottom: `G`.

- Go to the previous frame: `b`. Go to the next frame: `B`

- `h` to get the help menu.

## find

- `find / -type f -name ""`: `f` means type file, `d` means type directory

- `-perm xxx` to search for specific permissions

- `-user xxx`: to search for files belonging to a specific user

- `-group xxx`: similar thing as user

- `find / -type f -exec echo {} \;` Basically join everything you find into the little `{}` and exec against the executable provided (echo in this case)

- `find / -type f -mtime 365 -exec backup.sh {} \;`

# GNU core utilities

## chroot

- `sudo chroot $HOME/jail /bin/bash`: change root and execute command `/bin/bash`. Note, however, chroot doesn't automatically change the directory after the execution nor does it close file descriptors outside the jail.

## df

- shows disk free space on filesystems

## du

- shows disk usage on filesystems

## ln

- creates file links: `ln -s TARGET_FILE LINK`

- super useful for a lot reasons, even for shifting some files from `/` to `/home` just in case you forgot to give enough space to `/`

## basename

- strips path information from files. For instance, `basename ~/Desktop/unknown.png` gives `unknown.png`

## cut

- `cut -b 1,2,3 filename` basically cuts and returns the mentioned bytes from each line in the file

- `cut -c 1,2 filename` basically cuts and returns the first and second column from the filename

- `cut -d " " -f 1 filename` basically delimits using space and gets `$1` (much like awk, cut also cuts based on fields if -f is mentioned)

## wc

- print the number of bytes, words, and lines in files

## tee

- redirects output to multiple files. `command | tee file1.out file2.out file3.out`

- append flag: `-a`

- no output `command | tee file.out > /dev/null`

## nice

- change scheduling priority

## who

- displays all users logged in currently