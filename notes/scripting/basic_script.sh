#! /bin/bash

: '
	This be a weird multi-line comment technique
	Why not set another delimiter?
'
cat << BASH_HERE_DOC_DELIM
	A basic heredoc delimiter.
	echo "We are just characters. Not any command that bash recognises"
BASH_HERE_DOC_DELIM

count=10
if [ $count -eq 11 ]
then
	echo "Interestingly, bash doesn't like operator symbols"
else
	echo "Did it start liking symbols?"
fi

if (( $count == 10 ))
then
	echo "Now it started liking symbols..."
fi


if (( $count < 10 ))
then
	echo "do nothing I suppose"

elif (( $count == 10 ))
then
	echo "elif works like a charm"
else
	echo "nothing seems to work when I want it to work"
fi

number1=1
number2=20

if [ $number1 -ge 1 ] && [ $number2 -lt 21 ]
then
	echo "booleans work fine..."
fi

if [[ $number1 -eq 1 && $number2 -eq 20 ]] # also -a for && and -o for OR also works
then
	echo "just another way to write stuff"
fi




######################################################################

while [ $number1 -lt $number2 ]
do
	echo "Loop..."
	(( number1++ ))
	number1=$(( number1 + 1 ))
done
number1=1
until [ $number1 -gt $number2 ]
do
	echo "Until loop, like seriously? "
	number1=$(( number1+1 ))
done


for i in 1 2 3 4 5 6 7 8 10
do
	echo "$i I like to manually enumerate loop variables :)"
done

for i in {1..10}
do
	echo "$i But I can't really enumerate loop variables manually, can I?"
done

for j in { 1..2..20 }
do
	echo "$j I mean I am lazy to wait for step 1 increments"
done

for i in $( seq 1 1 10 )
do
	echo "$i you could probably do a linux command returning some sort of iterable I suppose. Not sure though..."
done


for (( i=0; i<5; i++ ))
do
	echo "Conventional good old FOR ;)"
done

####################################################################

variable_no_of_arguments=("$@")
echo ${variable_no_of_arguments[2]} # Use {} instead of (). () is asking to execute a command. {} is asking to simply index stuff

echo $@
echo "Number of arguments: $#" #this is the length of the arguments inputted


##################################################################

ls -al 1>file1 2>file2 # basic stdout and stderr redirect
cat file1
ls +al 2>file2 1>file1

ls +al >> file 2>&1   # file shall receiver redirects from the stderr and stdout
# ls +al >>& file 	also gets the same things as before

echo -n "Enter a string: "
read string1
echo -n "Enter another string: "
read string2
if [ $string1  == $string2 ] # -eq can't compare strings
then
	echo "The strings are equal"
elif [ $string1 \< $string2 ] # because a simple > or < is a redirection
then
	echo "$string1 is smaller"
elif [ $string1 \> $string2 ]
then
	echo "string2 is smaller"
fi
string1=${string1^}
string2=${string2^^}
echo "$string1$string2 is the master string"
echo "$string1 <- is the lowercase representation"
echo "$string2 <- is the uppercase representation"

############################################################
# basic arithmetic is enclosed within $(())

echo $(( number1 + number2 ))
echo $(( number1 * number2 ))
echo $(( number1 / number2 ))
echo $(expr $number1 - $number2) # another way to do stuff
echo $(expr $number1 \* $number2) # expr won't recognise *

echo -n "Binary to hex converter: "
echo "obase=16; ibase=10; 65535" | bc # the base converter

##########################################################
